# Tests for compose_composer extension
# Run with: tilt ci (from this directory)
# Or: make test (from parent directory)

# Only load public API (cc_init) and test exports function
load('../Tiltfile', 'cc_test_exports', 'cc_init')
load('./integration_test.tilt', 'run_integration_tests')

# Get internal functions for testing via cc_test_exports()
# This provides access to internal functions that aren't part of the public API
_internals = cc_test_exports()
deep_merge = _internals['deep_merge']
deep_copy = _internals['deep_copy']
collect_wire_when_rules = _internals['collect_wire_when_rules']
apply_wire_when_rules = _internals['apply_wire_when_rules']
is_url = _internals['is_url']
resolve_plugin_spec = _internals['resolve_plugin_spec']
struct_to_dict = _internals['struct_to_dict']
apply_modifications = _internals['apply_modifications']
add_target_wrapper = _internals['add_target_wrapper']
flatten_dependency_tree = _internals['flatten_dependency_tree']
is_dep_included_by_profile = _internals['is_dep_included_by_profile']
parse_url_with_ref = _internals['parse_url_with_ref']
get_compose_path_from_dep = _internals['get_compose_path_from_dep']
is_named_volume = _internals['is_named_volume']
run_plugin_setup = _internals['run_plugin_setup']
is_bindable_symbol = _internals['is_bindable_symbol']
RESERVED_SYMBOLS = _internals['RESERVED_SYMBOLS']
# Internal API functions (used by unit tests, production code uses cc_init() fluent API)
cc_create = _internals['cc_create']
cc_import = _internals['cc_import']
cc_generate_master_compose = _internals['cc_generate_master_compose']
cc_parse_cli_plugins = _internals['cc_parse_cli_plugins']
cc_docker_compose = _internals['cc_docker_compose']
cc_get_active_profiles = _internals['get_active_profiles']

# ============================================================================
# Test Helpers
# ============================================================================

def assert_equals(actual, expected, msg=""):
    """Assert that actual equals expected."""
    if actual != expected:
        fail_msg = "Expected '{}', got '{}'".format(expected, actual)
        if msg:
            fail_msg = msg + ": " + fail_msg
        fail(fail_msg)

def assert_true(condition, msg=""):
    """Assert that condition is true."""
    if not condition:
        fail(msg if msg else "Assertion failed")

def assert_in(item, collection, msg=""):
    """Assert that item is in collection."""
    if item not in collection:
        fail_msg = "'{}' not in '{}'".format(item, collection)
        if msg:
            fail_msg = msg + ": " + fail_msg
        fail(fail_msg)

# ============================================================================
# deep_merge Tests
# ============================================================================

def test_deep_merge_simple_dicts():
    """Test merging two simple dicts."""
    base = {'a': 1, 'b': 2}
    override = {'b': 3, 'c': 4}
    result = deep_merge(base, override)
    assert_equals(result['a'], 1, "Base value should be preserved")
    assert_equals(result['b'], 3, "Override should take precedence")
    assert_equals(result['c'], 4, "New key should be added")
    print("  [PASS] test_deep_merge_simple_dicts")

def test_deep_merge_nested_dicts():
    """Test merging nested dicts recursively."""
    base = {'outer': {'inner1': 'a', 'inner2': 'b'}}
    override = {'outer': {'inner2': 'c', 'inner3': 'd'}}
    result = deep_merge(base, override)
    assert_equals(result['outer']['inner1'], 'a', "Nested base value preserved")
    assert_equals(result['outer']['inner2'], 'c', "Nested override takes precedence")
    assert_equals(result['outer']['inner3'], 'd', "Nested new key added")
    print("  [PASS] test_deep_merge_nested_dicts")

def test_deep_merge_lists_concatenate():
    """Test that lists are concatenated, not replaced."""
    base = {'items': ['a', 'b']}
    override = {'items': ['c', 'd']}
    result = deep_merge(base, override)
    assert_equals(len(result['items']), 4, "Lists should be concatenated")
    assert_in('a', result['items'])
    assert_in('d', result['items'])
    print("  [PASS] test_deep_merge_lists_concatenate")

def test_deep_merge_lists_dedup():
    """Test that duplicate list items are not added."""
    base = {'items': ['a', 'b']}
    override = {'items': ['b', 'c']}
    result = deep_merge(base, override)
    assert_equals(len(result['items']), 3, "Duplicates should not be added")
    print("  [PASS] test_deep_merge_lists_dedup")

def test_deep_merge_does_not_mutate():
    """Test that base dict is not mutated."""
    base = {'a': 1}
    override = {'b': 2}
    result = deep_merge(base, override)
    assert_true('b' not in base, "Base should not be mutated")
    print("  [PASS] test_deep_merge_does_not_mutate")

def test_deep_merge_compose_overrides():
    """Test merging compose-like structures."""
    base = {
        'services': {
            'grafana': {
                'environment': {'VAR1': 'val1'},
                'volumes': ['/vol1:/mount1'],
            },
        },
    }
    override = {
        'services': {
            'grafana': {
                'environment': {'VAR2': 'val2'},
                'volumes': ['/vol2:/mount2'],
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['grafana']['environment']['VAR1'], 'val1')
    assert_equals(result['services']['grafana']['environment']['VAR2'], 'val2')
    assert_equals(len(result['services']['grafana']['volumes']), 2)
    print("  [PASS] test_deep_merge_compose_overrides")

# ============================================================================
# local_compose Tests
# ============================================================================

def test_cc_create_basic():
    """Test creating a basic cc_local_composable struct."""
    plugin = cc_create('my-plugin', '/path/to/compose.yaml')
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.compose_path, '/path/to/compose.yaml')
    assert_equals(len(plugin.dependencies), 0)
    assert_true(plugin._is_local)
    print("  [PASS] test_cc_create_basic")

def test_cc_create_with_dependencies():
    """Test creating cc_local_composable with dependencies."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    dep2 = struct(
        name='dep2',
        url='file:///path',
        ref=None,
        repo_path='dep2',
        compose_path='/path/dep2.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    plugin = cc_create('my-plugin', '/path/to/compose.yaml', dep1, dep2)
    assert_equals(len(plugin.dependencies), 2)
    assert_equals(plugin.dependencies[0].name, 'dep1')
    assert_equals(plugin.dependencies[1].name, 'dep2')
    print("  [PASS] test_cc_create_with_dependencies")

# ============================================================================
# flatten_dependency_tree Tests
# ============================================================================

def test_flatten_dependency_tree_simple():
    """Test flattening a simple dependency tree."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_create('root', '/path/root.yaml', dep1)
    result = flatten_dependency_tree(root, [])
    
    # Should have dep1 first, then root
    assert_equals(len(result), 2)
    assert_equals(result[0]['name'], 'dep1')
    assert_equals(result[1]['name'], 'root')
    print("  [PASS] test_flatten_dependency_tree_simple")

def test_flatten_dependency_tree_nested():
    """Test flattening nested dependencies."""
    dep_inner = struct(
        name='inner',
        url='file:///path',
        ref=None,
        repo_path='inner',
        compose_path='/path/inner.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep_outer = struct(
        name='outer',
        url='file:///path',
        ref=None,
        repo_path='outer',
        compose_path='/path/outer.yaml',
        _compose_overrides_param={},
        dependencies=[dep_inner],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_create('root', '/path/root.yaml', dep_outer)
    result = flatten_dependency_tree(root, [])
    
    # Should be: inner, outer, root (depth-first)
    assert_equals(len(result), 3)
    assert_equals(result[0]['name'], 'inner')
    assert_equals(result[1]['name'], 'outer')
    assert_equals(result[2]['name'], 'root')
    print("  [PASS] test_flatten_dependency_tree_nested")

def test_flatten_dependency_tree_deduplicates():
    """Test that duplicate dependencies are deduplicated."""
    shared_dep = struct(
        name='shared',
        url='file:///path',
        ref=None,
        repo_path='shared',
        compose_path='/path/shared.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        _compose_overrides_param={},
        dependencies=[shared_dep],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep2 = struct(
        name='dep2',
        url='file:///path',
        ref=None,
        repo_path='dep2',
        compose_path='/path/dep2.yaml',
        _compose_overrides_param={},
        dependencies=[shared_dep],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_create('root', '/path/root.yaml', dep1, dep2)
    result = flatten_dependency_tree(root, [])
    
    # Should be: shared (once), dep1, dep2, root
    names = [r['name'] for r in result]
    shared_count = len([n for n in names if n == 'shared'])
    assert_equals(shared_count, 1, "Shared dep should only appear once")
    assert_equals(len(result), 4)
    print("  [PASS] test_flatten_dependency_tree_deduplicates")

def test_flatten_dependency_tree_with_cli_plugins():
    """Test flattening with CLI plugins."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    cli_plugin = struct(
        name='cli-plugin',
        url='file:///path',
        ref=None,
        repo_path='cli-plugin',
        compose_path='/path/cli.yaml',
        _compose_overrides_param={},
        dependencies=[],
        _symbols={},
        _from_cli=True,
        _is_local=False,
    )
    
    root = cc_create('root', '/path/root.yaml', dep1)
    result = flatten_dependency_tree(root, [cli_plugin])
    
    # Should have: dep1, root, cli-plugin
    names = [r['name'] for r in result]
    assert_in('dep1', names)
    assert_in('root', names)
    assert_in('cli-plugin', names)
    print("  [PASS] test_flatten_dependency_tree_with_cli_plugins")

# ============================================================================
# is_url Tests
# ============================================================================

def test_is_url_https():
    """Test HTTPS URL detection."""
    assert_true(is_url('https://github.com/org/repo.git'), "HTTPS should be detected")
    print("  [PASS] test_is_url_https")

def test_is_url_file():
    """Test file:// URL detection."""
    assert_true(is_url('file:///path/to/dir'), "file:// should be detected")
    print("  [PASS] test_is_url_file")

def test_is_url_git_ssh():
    """Test git SSH URL detection."""
    assert_true(is_url('git@github.com:org/repo.git'), "git@ should be detected")
    print("  [PASS] test_is_url_git_ssh")

def test_is_url_not_url():
    """Test non-URL strings."""
    assert_true(not is_url('plugin-name'), "Plain name should not be URL")
    assert_true(not is_url('../relative/path'), "Relative path should not be URL")
    assert_true(not is_url('/absolute/path'), "Absolute path should not be URL")
    print("  [PASS] test_is_url_not_url")

# ============================================================================
# resolve_plugin_spec Tests
# ============================================================================

def test_resolve_plugin_spec_url():
    """Test URL passthrough - standalone composable (no fragment)."""
    result = resolve_plugin_spec('https://github.com/org/repo.git', '/base')
    assert_equals(result['url'], 'https://github.com/org/repo.git')
    assert_equals(result['name'], 'repo')
    assert_equals(result['repo_path'], '.', "Standalone URL should have repo_path='.'")
    assert_true(result['_from_cli'])
    print("  [PASS] test_resolve_plugin_spec_url")

def test_resolve_plugin_spec_url_with_fragment():
    """Test URL with fragment specifying subdirectory (collection URL)."""
    result = resolve_plugin_spec('https://github.com/org/composables#grafana', '/base')
    assert_equals(result['url'], 'https://github.com/org/composables')
    assert_equals(result['name'], 'grafana')
    assert_equals(result['repo_path'], 'grafana', "Fragment should become repo_path")
    assert_true(result['_from_cli'])
    print("  [PASS] test_resolve_plugin_spec_url_with_fragment")

def test_resolve_plugin_spec_url_with_ref_and_fragment():
    """Test URL with both @ref and #fragment."""
    result = resolve_plugin_spec('https://github.com/org/composables@v1.0#grafana', '/base')
    assert_equals(result['url'], 'https://github.com/org/composables@v1.0', "URL should keep @ref")
    assert_equals(result['name'], 'grafana')
    assert_equals(result['repo_path'], 'grafana')
    print("  [PASS] test_resolve_plugin_spec_url_with_ref_and_fragment")

def test_resolve_plugin_spec_url_with_nested_fragment():
    """Test URL with nested path in fragment."""
    result = resolve_plugin_spec('https://github.com/org/repo#path/to/plugin', '/base')
    assert_equals(result['url'], 'https://github.com/org/repo')
    assert_equals(result['name'], 'plugin', "Name should be last segment of fragment")
    assert_equals(result['repo_path'], 'path/to/plugin', "repo_path should be full fragment")
    print("  [PASS] test_resolve_plugin_spec_url_with_nested_fragment")

def test_resolve_plugin_spec_absolute():
    """Test absolute path conversion to file:// URL."""
    result = resolve_plugin_spec('/absolute/path/to/plugin', '/base')
    assert_true(result['url'].startswith('file://'))
    assert_in('/absolute/path/to/plugin', result['url'])
    assert_equals(result['name'], 'plugin')
    print("  [PASS] test_resolve_plugin_spec_absolute")

def test_resolve_plugin_spec_relative():
    """Test relative path resolution."""
    result = resolve_plugin_spec('./subdir/plugin', '/base/dir')
    assert_true(result['url'].startswith('file://'))
    assert_equals(result['name'], 'plugin')
    assert_equals(result['repo_path'], '.')
    print("  [PASS] test_resolve_plugin_spec_relative")

def test_resolve_plugin_spec_adjacent():
    """Test adjacent directory (plain name) resolution."""
    result = resolve_plugin_spec('sibling-plugin', '/base/my-plugin')
    assert_true(result['url'].startswith('file://'))
    assert_equals(result['name'], 'sibling-plugin')
    print("  [PASS] test_resolve_plugin_spec_adjacent")

# ============================================================================
# collect_wire_when_rules Tests
# ============================================================================

def test_collect_wire_when_rules_empty():
    """Test with no extensions exporting wire_when."""
    deps = [
        {'name': 'dep1', 'symbols': {}},
        {'name': 'dep2', 'symbols': {'other_fn': lambda: None}},
    ]
    result = collect_wire_when_rules(deps)
    assert_equals(len(result), 0, "Should be empty when no wire_when")
    print("  [PASS] test_collect_wire_when_rules_empty")

def test_collect_wire_when_rules_single():
    """Test collecting rules from one extension."""
    def mock_wire_when():
        return {
            'k3s-apiserver': {
                'services': {
                    'grafana': {'depends_on': ['k3s-apiserver']},
                },
            },
        }
    
    deps = [
        {'name': 'grafana', 'symbols': {'cc_wire_when': mock_wire_when}},
    ]
    result = collect_wire_when_rules(deps)
    assert_in('k3s-apiserver', result)
    assert_equals(len(result['k3s-apiserver']), 1)
    assert_equals(result['k3s-apiserver'][0]['source_dep'], 'grafana')
    print("  [PASS] test_collect_wire_when_rules_single")

def test_collect_wire_when_rules_multiple():
    """Test collecting rules from multiple extensions."""
    def wire_when_1():
        return {'k3s-apiserver': {'services': {'svc1': {}}}}
    
    def wire_when_2():
        return {'k3s-apiserver': {'services': {'svc2': {}}}}
    
    deps = [
        {'name': 'ext1', 'symbols': {'cc_wire_when': wire_when_1}},
        {'name': 'ext2', 'symbols': {'cc_wire_when': wire_when_2}},
    ]
    result = collect_wire_when_rules(deps)
    assert_in('k3s-apiserver', result)
    assert_equals(len(result['k3s-apiserver']), 2, "Should have rules from both extensions")
    print("  [PASS] test_collect_wire_when_rules_multiple")

# ============================================================================
# apply_wire_when_rules Tests
# ============================================================================

def test_apply_wire_when_rules_adds_depends_on():
    """Test that depends_on is added correctly."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'depends_on': ['k3s-apiserver']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_in('k3s-apiserver', result['services']['grafana']['depends_on'])
    print("  [PASS] test_apply_wire_when_rules_adds_depends_on")

def test_apply_wire_when_rules_adds_volumes():
    """Test that volumes are added correctly."""
    compose = {
        'services': {
            'grafana': {'volumes': ['/existing:/mount']},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'volumes': ['k3s-certs:/certs:ro']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_equals(len(result['services']['grafana']['volumes']), 2)
    print("  [PASS] test_apply_wire_when_rules_adds_volumes")

def test_apply_wire_when_rules_adds_environment():
    """Test that environment variables are added correctly."""
    compose = {
        'services': {
            'grafana': {'environment': {'EXISTING': 'value'}},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'environment': {'NEW_VAR': 'new_value'}},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_equals(result['services']['grafana']['environment']['EXISTING'], 'value')
    assert_equals(result['services']['grafana']['environment']['NEW_VAR'], 'new_value')
    print("  [PASS] test_apply_wire_when_rules_adds_environment")

def test_apply_wire_when_rules_skips_when_trigger_missing():
    """Test that rules don't apply when trigger dependency is missing."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'depends_on': ['k3s-apiserver']},
                    },
                },
            },
        ],
    }
    # k3s-apiserver is NOT in loaded_dep_names
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'mysql'])
    assert_true('depends_on' not in result['services']['grafana'], "Should not apply when trigger missing")
    print("  [PASS] test_apply_wire_when_rules_skips_when_trigger_missing")

def test_apply_wire_when_rules_creates_top_level_volumes():
    """Test that named volumes are added to top-level volumes section."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'volumes': ['k3s-certs:/certs:ro']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_in('volumes', result)
    assert_in('k3s-certs', result['volumes'])
    print("  [PASS] test_apply_wire_when_rules_creates_top_level_volumes")

# ============================================================================
# struct_to_dict Tests
# ============================================================================

def test_struct_to_dict_basic():
    """Test converting a basic struct to dict."""
    s = struct(
        name='test-dep',
        url='file:///path',
        ref=None,
        repo_path='test-dep',
        compose_path='/path/compose.yaml',
        compose_overrides={'services': {}},
        dependencies=[],
        _symbols={'fn': lambda: None},
        _from_cli=False,
        _is_local=False,
    )
    result = struct_to_dict(s)
    assert_equals(result['name'], 'test-dep')
    assert_equals(result['url'], 'file:///path')
    assert_equals(result['_from_cli'], False)
    assert_true('symbols' in result, "Should have symbols key")
    print("  [PASS] test_struct_to_dict_basic")

def test_struct_to_dict_cc_create():
    """Test converting a cc_local_composable struct to dict."""
    plugin = cc_create('my-plugin', '/path/to/compose.yaml')
    result = struct_to_dict(plugin)
    assert_equals(result['name'], 'my-plugin')
    assert_equals(result['compose_path'], '/path/to/compose.yaml')
    assert_true(result['_is_local'])
    print("  [PASS] test_struct_to_dict_cc_local_composable")

def test_struct_to_dict_preserves_compose_overrides():
    """Test that compose_overrides are preserved."""
    overrides = {'services': {'svc': {'environment': {'VAR': 'val'}}}}
    s = struct(
        name='test',
        url='file:///path',
        ref=None,
        repo_path='test',
        compose_path='/path/compose.yaml',
        _compose_overrides_param=overrides,
        dependencies=[],
        _symbols={},
        _from_cli=True,
        _is_local=False,
    )
    result = struct_to_dict(s)
    assert_equals(result['_compose_overrides_param']['services']['svc']['environment']['VAR'], 'val')
    print("  [PASS] test_struct_to_dict_preserves_compose_overrides")

# ============================================================================
# apply_modifications Tests
# ============================================================================

def test_apply_modifications_single():
    """Test applying a single modification."""
    deps = [
        {'name': 'k3s-apiserver', 'url': 'file:///path', '_compose_overrides_param': {}},
        {'name': 'mysql', 'url': 'file:///path', '_compose_overrides_param': {}},
    ]
    mods = [
        {
            '_target': 'k3s-apiserver',
            'services': {'crd-loader': {'volumes': ['/crds:/crds:ro']}},
        },
    ]
    apply_modifications(deps, mods)
    assert_in('services', deps[0]['_compose_overrides_param'])
    assert_in('crd-loader', deps[0]['_compose_overrides_param']['services'])
    print("  [PASS] test_apply_modifications_single")

def test_apply_modifications_multiple_same_target():
    """Test applying multiple modifications to the same target."""
    deps = [
        {'name': 'k3s-apiserver', 'url': 'file:///path', '_compose_overrides_param': {}},
    ]
    mods = [
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/path1:/crds/p1:ro']}}},
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/path2:/crds/p2:ro']}}},
    ]
    apply_modifications(deps, mods)
    volumes = deps[0]['_compose_overrides_param']['services']['crd-loader']['volumes']
    assert_equals(len(volumes), 2, "Both modifications should be merged")
    print("  [PASS] test_apply_modifications_multiple_same_target")

def test_apply_modifications_missing_target():
    """Test that modifications with missing targets are skipped."""
    deps = [
        {'name': 'mysql', 'url': 'file:///path', '_compose_overrides_param': {}},
    ]
    mods = [
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/crds:/crds:ro']}}},
    ]
    # Should not fail, just skip
    apply_modifications(deps, mods)
    assert_equals(deps[0]['_compose_overrides_param'], {}, "Should not be modified")
    print("  [PASS] test_apply_modifications_missing_target")

# ============================================================================
# add_target_wrapper Tests
# ============================================================================

def test_add_target_wrapper_adds_target():
    """Test that wrapper adds _target to result."""
    def original_fn():
        return {'services': {'svc': {}}}

    # Pass cc=None for backwards compatibility
    wrapped = add_target_wrapper(original_fn, 'test-dep', None)
    result = wrapped()

    assert_in('_target', result)
    assert_equals(result['_target'], 'test-dep')
    print("  [PASS] test_add_target_wrapper_adds_target")

def test_add_target_wrapper_passes_through_args():
    """Test that wrapper passes arguments through."""
    received = []
    def original_fn(crd_paths):
        received.append(crd_paths)
        return {'services': {}}

    # Pass cc=None for backwards compatibility
    wrapped = add_target_wrapper(original_fn, 'test-dep', None)
    wrapped(['/path/to/crds'])

    assert_equals(received[0], ['/path/to/crds'], "Args should pass through")
    print("  [PASS] test_add_target_wrapper_passes_through_args")

def test_add_target_wrapper_injects_cc():
    """Test that wrapper injects cc as first argument when cc is provided."""
    received = []
    def helper_fn(cc, crd_paths):
        received.append({'cc': cc, 'paths': crd_paths})
        return {'services': {}}

    # Create a mock cc struct
    mock_cc = struct(name='test-project', staging_dir='/tmp')

    wrapped = add_target_wrapper(helper_fn, 'test-dep', mock_cc)
    wrapped(['/path/to/crds'])

    assert_equals(received[0]['cc'].name, 'test-project', "cc should be injected")
    assert_equals(received[0]['paths'], ['/path/to/crds'], "Args should pass through after cc")
    print("  [PASS] test_add_target_wrapper_injects_cc")

# ============================================================================
# Profile Tests
# ============================================================================

def test_is_dep_included_no_profiles_always_included():
    """Test that deps with no profiles are always included."""
    # No profiles on dep = always included
    assert_true(is_dep_included_by_profile([], []), "No profiles, no active = included")
    assert_true(is_dep_included_by_profile([], ['dev']), "No profiles, active dev = included")
    assert_true(is_dep_included_by_profile([], ['dev', 'staging']), "No profiles, multiple active = included")
    print("  [PASS] test_is_dep_included_no_profiles_always_included")

def test_is_dep_included_with_profiles_needs_match():
    """Test that deps with profiles need at least one match."""
    # Dep has profiles, no active profiles = excluded
    assert_true(not is_dep_included_by_profile(['dev'], []), "Has profile, no active = excluded")
    
    # Dep has profiles, matching active = included
    assert_true(is_dep_included_by_profile(['dev'], ['dev']), "Matching profile = included")
    assert_true(is_dep_included_by_profile(['dev', 'staging'], ['dev']), "One match = included")
    assert_true(is_dep_included_by_profile(['dev'], ['dev', 'staging']), "One match = included")
    
    # Dep has profiles, no match = excluded
    assert_true(not is_dep_included_by_profile(['dev'], ['staging']), "No match = excluded")
    assert_true(not is_dep_included_by_profile(['dev', 'full'], ['staging', 'test']), "No match = excluded")
    print("  [PASS] test_is_dep_included_with_profiles_needs_match")

def test_cc_create_with_profiles():
    """Test creating cc_local_composable with profiles."""
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
        profiles=['dev', 'staging'],
    )
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.profiles, ['dev', 'staging'])
    print("  [PASS] test_cc_create_with_profiles")

def test_cc_create_with_labels():
    """Test creating cc_local_composable with labels."""
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
        labels=['app'],
    )
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.labels, ['app'])
    print("  [PASS] test_cc_create_with_labels")

def test_cc_create_labels_default_empty():
    """Test that labels default to empty list."""
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
    )
    assert_equals(plugin.labels, [])
    print("  [PASS] test_cc_create_labels_default_empty")

# ============================================================================
# resource_deps Tests
# ============================================================================

def test_struct_with_resource_deps():
    """Test creating a struct with resource_deps."""
    # Create a mock dependency struct with resource_deps
    dep = struct(
        name='test-dep',
        url='file:///path',
        ref=None,
        repo_path='test-dep',
        compose_path='/path/compose.yaml',
        _compose_overrides_param={},
        dependencies=[],
        profiles=[],
        labels=['infra'],
        resource_deps=['frontend-build', 'backend-build'],
        _symbols={},
        _from_cli=False,
        _is_local=False,
        modifications=[],
    )
    assert_equals(len(dep.resource_deps), 2)
    assert_in('frontend-build', dep.resource_deps)
    assert_in('backend-build', dep.resource_deps)
    print("  [PASS] test_struct_with_resource_deps")

def test_struct_to_dict_preserves_resource_deps():
    """Test that struct_to_dict preserves resource_deps field."""
    dep = struct(
        name='test-dep',
        url='file:///path',
        ref=None,
        repo_path='test-dep',
        compose_path='/path/compose.yaml',
        _compose_overrides_param={},
        dependencies=[],
        profiles=[],
        labels=[],
        resource_deps=['build-task'],
        _symbols={},
        _from_cli=False,
        _is_local=False,
        modifications=[],
    )
    dep_dict = struct_to_dict(dep)
    assert_equals(len(dep_dict['resource_deps']), 1)
    assert_in('build-task', dep_dict['resource_deps'])
    print("  [PASS] test_struct_to_dict_preserves_resource_deps")

def test_struct_to_dict_resource_deps_default_empty():
    """Test that resource_deps defaults to empty list when not specified."""
    dep = struct(
        name='test-dep',
        url='file:///path',
        ref=None,
        repo_path='test-dep',
        compose_path='/path/compose.yaml',
        _compose_overrides_param={},
        dependencies=[],
        profiles=[],
        labels=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
        modifications=[],
    )
    dep_dict = struct_to_dict(dep)
    assert_equals(dep_dict['resource_deps'], [])
    print("  [PASS] test_struct_to_dict_resource_deps_default_empty")

def test_cc_create_resource_deps_default_empty():
    """Test that cc_create defaults resource_deps to empty list."""
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
    )
    # cc_create doesn't support resource_deps parameter, so it won't have the field
    # This is expected since we only added resource_deps to cc_import
    assert_true(not hasattr(plugin, 'resource_deps'), "cc_create should not have resource_deps field")
    print("  [PASS] test_cc_create_resource_deps_default_empty")

# ============================================================================
# Modifications Tests
# ============================================================================

def test_cc_create_with_modifications():
    """Test creating cc_local_composable with modifications parameter."""
    # Create a mock modification dict
    mod = {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['test:/test']}}}

    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod],
    )
    assert_equals(plugin.name, 'my-plugin')
    # modifications is now a method that returns the list
    mods = plugin.modifications()
    assert_equals(len(mods), 1)
    assert_equals(mods[0]['_target'], 'k3s-apiserver')
    print("  [PASS] test_cc_create_with_modifications")

def test_cc_create_modifications_default_empty():
    """Test that modifications default to empty list."""
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
    )
    # modifications is now a method that returns the list
    assert_equals(plugin.modifications(), [])
    print("  [PASS] test_cc_create_modifications_default_empty")

def test_cc_create_multiple_modifications():
    """Test plugin with multiple modifications."""
    mod1 = {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['crds1:/crds1']}}}
    mod2 = {'_target': 'mysql', 'services': {'db': {'environment': ['TEST=1']}}}

    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod1, mod2],
    )
    # modifications is now a method that returns the list
    mods = plugin.modifications()
    assert_equals(len(mods), 2)
    assert_equals(mods[0]['_target'], 'k3s-apiserver')
    assert_equals(mods[1]['_target'], 'mysql')
    print("  [PASS] test_cc_create_multiple_modifications")

def test_struct_to_dict_preserves_modifications():
    """Test that struct_to_dict preserves modifications field."""
    mod = {'_target': 'k3s-apiserver', 'services': {'test': {}}}
    plugin = cc_create(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod],
    )

    plugin_dict = struct_to_dict(plugin)
    assert_equals(len(plugin_dict['modifications']), 1)
    assert_equals(plugin_dict['modifications'][0]['_target'], 'k3s-apiserver')
    print("  [PASS] test_struct_to_dict_preserves_modifications")

def test_flatten_dependency_tree_with_profiles():
    """Test that dependency tree respects profiles."""
    always_included = struct(
        name='always',
        url='file:///path',
        ref=None,
        repo_path='always',
        compose_path='/path/always.yaml',
        _compose_overrides_param={},
        dependencies=[],
        profiles=[],  # No profiles = always included
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dev_only = struct(
        name='dev-only',
        url='file:///path',
        ref=None,
        repo_path='dev-only',
        compose_path='/path/dev.yaml',
        _compose_overrides_param={},
        dependencies=[],
        profiles=['dev'],  # Only in dev
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_create('root', '/path/root.yaml', always_included, dev_only)
    
    # With no active profiles, only 'always' should be included
    result = flatten_dependency_tree(root, [], None, [])
    names = [r['name'] for r in result]
    assert_in('always', names)
    assert_in('root', names)
    assert_true('dev-only' not in names, "dev-only should be excluded with no profiles")
    
    # With 'dev' profile, both should be included
    result_dev = flatten_dependency_tree(root, [], None, ['dev'])
    names_dev = [r['name'] for r in result_dev]
    assert_in('always', names_dev)
    assert_in('dev-only', names_dev)
    assert_in('root', names_dev)
    
    print("  [PASS] test_flatten_dependency_tree_with_profiles")

def test_cc_get_active_profiles():
    """Test that cc_get_active_profiles returns a list."""
    profiles = cc_get_active_profiles()
    assert_true(type(profiles) == 'list', "Should return a list")
    print("  [PASS] test_cc_get_active_profiles")

# ============================================================================
# compose_overrides Method Tests
# ============================================================================

def test_compose_overrides_method_exists_on_local():
    """Test that compose_overrides() method exists on local composables."""
    local = cc_create(
        'test-local',
        os.path.dirname(__file__) + '/test-compose.yaml',
    )

    assert_true(hasattr(local, 'compose_overrides'), "compose_overrides() method not found on local composable")

    # Test that we can call it
    result = local.compose_overrides({'services': {'test': {}}})
    assert_true('_target' in result, "compose_overrides() should return dict with _target")

    print("  [PASS] test_compose_overrides_method_exists_on_local")

def test_compose_overrides_method_returns_modification():
    """Test that compose_overrides() method returns proper modification dict."""
    # Use local composable to avoid circular dependency
    mock_dep = cc_create('mock-dep', '/path/to/compose.yaml')

    overrides = {
        'services': {
            'db': {
                'environment': {
                    'MYSQL_ROOT_PASSWORD': 'test123',
                },
            },
        },
    }

    result = mock_dep.compose_overrides(overrides)

    # Should have _target
    assert_true('_target' in result, "compose_overrides() result missing _target field")
    assert_equals(result['_target'], 'mock-dep', "compose_overrides() _target should match dep name")

    # Should have the overrides
    assert_true('services' in result, "compose_overrides() result missing services")

    print("  [PASS] test_compose_overrides_method_returns_modification")

# ============================================================================
# URL Parsing Tests
# ============================================================================

def test_parse_url_with_ref_https_tag():
    url, ref = parse_url_with_ref('https://github.com/user/repo@v1.0.0')
    assert_equals(url, 'https://github.com/user/repo', "URL should be without @ref")
    assert_equals(ref, 'v1.0.0', "Ref should be v1.0.0")
    print("  [PASS] test_parse_url_with_ref_https_tag")

def test_parse_url_with_ref_https_branch():
    url, ref = parse_url_with_ref('https://github.com/user/repo@main')
    assert_equals(url, 'https://github.com/user/repo', "URL should be without @ref")
    assert_equals(ref, 'main', "Ref should be main")
    print("  [PASS] test_parse_url_with_ref_https_branch")

def test_parse_url_with_ref_https_commit():
    url, ref = parse_url_with_ref('https://github.com/user/repo@abc123def')
    assert_equals(url, 'https://github.com/user/repo', "URL should be without @ref")
    assert_equals(ref, 'abc123def', "Ref should be abc123def")
    print("  [PASS] test_parse_url_with_ref_https_commit")

def test_parse_url_with_ref_no_ref():
    url, ref = parse_url_with_ref('https://github.com/user/repo')
    assert_equals(url, 'https://github.com/user/repo', "URL should be unchanged")
    assert_equals(ref, None, "Ref should be None")
    print("  [PASS] test_parse_url_with_ref_no_ref")

def test_parse_url_with_ref_file_url():
    url, ref = parse_url_with_ref('file:///path/to/repo@should-be-ignored')
    assert_equals(url, 'file:///path/to/repo@should-be-ignored', "file:// URL should not be parsed")
    assert_equals(ref, None, "file:// URLs should never have refs")
    print("  [PASS] test_parse_url_with_ref_file_url")

def test_parse_url_with_ref_ssh_url():
    url, ref = parse_url_with_ref('git@github.com:user/repo@v1.0.0')
    assert_equals(url, 'git@github.com:user/repo', "Should split on last @")
    assert_equals(ref, 'v1.0.0', "Ref should be v1.0.0")
    print("  [PASS] test_parse_url_with_ref_ssh_url")

def test_parse_url_with_ref_empty_ref():
    url, ref = parse_url_with_ref('https://github.com/user/repo@')
    assert_equals(url, 'https://github.com/user/repo@', "Empty ref should not be parsed")
    assert_equals(ref, None, "Empty ref should be None")
    print("  [PASS] test_parse_url_with_ref_empty_ref")

# ============================================================================
# Phase 4: Volume Mount Validation Tests (Bugs #5, #6 - Fixed)
# ============================================================================

def test_is_named_volume_unix_absolute_path():
    """Test that absolute Unix paths are NOT named volumes."""
    assert_equals(is_named_volume('/var/lib/data'), False, "Absolute path should not be named volume")
    print("  [PASS] test_is_named_volume_unix_absolute_path")

def test_is_named_volume_relative_path():
    """Test that relative paths are NOT named volumes."""
    assert_equals(is_named_volume('./data'), False, "Relative ./ path should not be named volume")
    assert_equals(is_named_volume('../data'), False, "Relative ../ path should not be named volume")
    print("  [PASS] test_is_named_volume_relative_path")

def test_is_named_volume_windows_path():
    """Test that Windows paths are NOT named volumes."""
    assert_equals(is_named_volume('C:\\data'), False, "Windows C: path should not be named volume")
    assert_equals(is_named_volume('D:/data'), False, "Windows D: path should not be named volume")
    print("  [PASS] test_is_named_volume_windows_path")

def test_is_named_volume_unc_path():
    """Test that UNC paths are NOT named volumes."""
    assert_equals(is_named_volume('\\\\server\\share'), False, "UNC path should not be named volume")
    print("  [PASS] test_is_named_volume_unc_path")

def test_is_named_volume_environment_variable():
    """Test that environment variables are NOT named volumes."""
    assert_equals(is_named_volume('${HOME}/data'), False, "Env var ${} should not be named volume")
    assert_equals(is_named_volume('$(pwd)/data'), False, "Env var $() should not be named volume")
    print("  [PASS] test_is_named_volume_environment_variable")

def test_is_named_volume_tilde_expansion():
    """Test that tilde paths are NOT named volumes."""
    assert_equals(is_named_volume('~/data'), False, "Tilde path should not be named volume")
    print("  [PASS] test_is_named_volume_tilde_expansion")

def test_is_named_volume_actual_named_volume():
    """Test that actual named volumes ARE detected."""
    assert_equals(is_named_volume('my-data-volume'), True, "Named volume should be detected")
    assert_equals(is_named_volume('postgres_data'), True, "Named volume with underscore should be detected")
    print("  [PASS] test_is_named_volume_actual_named_volume")

def test_is_named_volume_empty():
    """Test that empty/None values return False."""
    assert_equals(is_named_volume(''), False, "Empty string should not be named volume")
    assert_equals(is_named_volume(None), False, "None should not be named volume")
    print("  [PASS] test_is_named_volume_empty")

def test_wire_when_volumes_exact_match_no_false_positive():
    """Test that volume mount point matching is exact, not substring."""
    # Bug #5: Previously '/data' would match '/mydata:/data' incorrectly
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'volumes': ['/existing-data:/data']  # Mount point is /data
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'volumes': ['/different-data:/data']  # Same mount point, different source
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    # Should not add duplicate - same mount point
    volumes = result['services']['test']['volumes']
    assert_equals(len(volumes), 1, "Should not add duplicate mount to same mount point")
    print("  [PASS] test_wire_when_volumes_exact_match_no_false_positive")

def test_wire_when_volumes_different_mount_points():
    """Test that different mount points are both added."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'volumes': ['/source1:/mount1']
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'volumes': ['/source2:/mount2']  # Different mount point
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    volumes = result['services']['test']['volumes']
    assert_equals(len(volumes), 2, "Should have both volumes with different mount points")
    print("  [PASS] test_wire_when_volumes_different_mount_points")

def test_wire_when_volumes_named_volume_detection():
    """Test that named volumes are properly added to top-level volumes section."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'volumes': []
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'volumes': ['my-named-volume:/data']  # Named volume
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    # Check service volumes
    volumes = result['services']['test']['volumes']
    assert_equals(len(volumes), 1, "Should have volume in service")

    # Check top-level volumes section
    assert_true('volumes' in result, "Should have top-level volumes section")
    assert_true('my-named-volume' in result['volumes'], "Named volume should be in top-level")
    print("  [PASS] test_wire_when_volumes_named_volume_detection")

def test_wire_when_volumes_bind_mount_no_toplevel():
    """Test that bind mounts are NOT added to top-level volumes."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'volumes': []
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'volumes': ['/host/path:/container/path']  # Bind mount
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    # Check service volumes
    volumes = result['services']['test']['volumes']
    assert_equals(len(volumes), 1, "Should have volume in service")

    # Top-level volumes should not have the bind mount path
    if 'volumes' in result:
        assert_true('/host/path' not in result['volumes'], "Bind mount should not be in top-level volumes")
    print("  [PASS] test_wire_when_volumes_bind_mount_no_toplevel")

# ============================================================================
# Phase 5: Silent Failure Warnings Tests (Bug #9 - Fixed)
# ============================================================================

def test_wire_when_environment_list_format_valid():
    """Test that valid environment list format is converted correctly."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'environment': ['KEY1=value1', 'KEY2=value2']  # List format
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'environment': {'KEY3': 'value3'}
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    env = result['services']['test']['environment']
    assert_true(type(env) == 'dict', "Environment should be converted to dict")
    assert_equals(env['KEY1'], 'value1', "KEY1 should be present")
    assert_equals(env['KEY2'], 'value2', "KEY2 should be present")
    assert_equals(env['KEY3'], 'value3', "KEY3 should be added")
    print("  [PASS] test_wire_when_environment_list_format_valid")

def test_wire_when_environment_list_format_with_equals_in_value():
    """Test that environment values containing '=' are handled correctly."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'environment': ['CONNECTION_STRING=host=localhost;user=admin']
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'environment': {'NEW_KEY': 'value'}
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    env = result['services']['test']['environment']
    assert_equals(env['CONNECTION_STRING'], 'host=localhost;user=admin', "Value with '=' should be preserved")
    print("  [PASS] test_wire_when_environment_list_format_with_equals_in_value")

def test_wire_when_environment_empty_value():
    """Test that environment entries with empty values are handled."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'environment': ['EMPTY_VAR=']  # Empty value
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'environment': {'KEY': 'value'}
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    env = result['services']['test']['environment']
    assert_equals(env['EMPTY_VAR'], '', "Empty value should be preserved as empty string")
    print("  [PASS] test_wire_when_environment_empty_value")

def test_wire_when_labels_list_format_valid():
    """Test that valid labels list format is converted correctly."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'labels': ['app=myapp', 'version=1.0']  # List format
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'labels': {'environment': 'prod'}
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    labels = result['services']['test']['labels']
    assert_true(type(labels) == 'dict', "Labels should be converted to dict")
    assert_equals(labels['app'], 'myapp', "app label should be present")
    assert_equals(labels['version'], '1.0', "version label should be present")
    assert_equals(labels['environment'], 'prod', "environment label should be added")
    print("  [PASS] test_wire_when_labels_list_format_valid")

def test_wire_when_labels_with_equals_in_value():
    """Test that label values containing '=' are handled correctly."""
    compose_yaml = {
        'services': {
            'test': {
                'image': 'test:latest',
                'labels': ['description=key=value pairs']
            }
        }
    }

    wire_when_rules = {
        'trigger': [{
            'source_dep': 'test-dep',
            'rules': {
                'services': {
                    'test': {
                        'labels': {'new': 'label'}
                    }
                }
            }
        }]
    }

    result = apply_wire_when_rules(compose_yaml, 'trigger', wire_when_rules, ['trigger'])

    labels = result['services']['test']['labels']
    assert_equals(labels['description'], 'key=value pairs', "Value with '=' should be preserved")
    print("  [PASS] test_wire_when_labels_with_equals_in_value")

# ============================================================================
# Phase 6: Additional Safety Tests (Bugs #7, #8, #10, #11 - Fixed)
# ============================================================================

def test_resolve_plugin_spec_url_valid():
    """Test that valid URLs are parsed correctly."""
    result = resolve_plugin_spec('https://github.com/user/repo.git', '/fake/dir')
    assert_equals(result['name'], 'repo', "Should extract repo name")
    assert_equals(result['url'], 'https://github.com/user/repo.git', "Should preserve URL")
    print("  [PASS] test_resolve_plugin_spec_url_valid")

def test_resolve_plugin_spec_url_with_ref():
    """Test that URLs with refs are parsed correctly."""
    result = resolve_plugin_spec('https://github.com/user/repo@main', '/fake/dir')
    assert_equals(result['name'], 'repo', "Should extract repo name without ref")
    print("  [PASS] test_resolve_plugin_spec_url_with_ref")

def test_resolve_plugin_spec_url_nested_path():
    """Test that nested repository paths are handled."""
    result = resolve_plugin_spec('https://github.com/user/repo/path/to/plugin', '/fake/dir')
    assert_equals(result['name'], 'plugin', "Should extract last segment")
    print("  [PASS] test_resolve_plugin_spec_url_nested_path")

def test_resolve_plugin_spec_git_ssh():
    """Test that git SSH URLs are parsed correctly."""
    result = resolve_plugin_spec('git@github.com:user/repo.git', '/fake/dir')
    assert_equals(result['name'], 'repo', "Should extract repo name from SSH URL")
    print("  [PASS] test_resolve_plugin_spec_git_ssh")

def test_collect_wire_when_rules_with_valid_dict():
    """Test that valid wire_when rules are collected."""
    # Create mock dependencies with cc_wire_when
    dep1 = struct_to_dict(cc_create('dep1', '/path/to/dep1.yaml'))
    dep1['symbols'] = {
        'cc_wire_when': lambda: {
            'trigger': {
                'services': {
                    'test': {
                        'depends_on': ['dep1']
                    }
                }
            }
        }
    }

    rules = collect_wire_when_rules([dep1])
    assert_true('trigger' in rules, "Should have trigger key")
    assert_equals(len(rules['trigger']), 1, "Should have one rule set")
    print("  [PASS] test_collect_wire_when_rules_with_valid_dict")

def test_deep_copy_documentation():
    """Test that deep_copy works correctly and verify it's well-documented."""
    original = {'a': 1, 'nested': {'b': 2}}
    copied = deep_copy(original)

    # Verify deep copy works
    assert_equals(copied['a'], 1, "Should copy values")
    assert_equals(copied['nested']['b'], 2, "Should copy nested values")

    # Verify isolation
    copied['a'] = 999
    assert_equals(original['a'], 1, "Original should not be mutated")
    print("  [PASS] test_deep_copy_documentation")

def test_path_traversal_is_allowed():
    """Test that relative path traversal is intentionally allowed (documented behavior)."""
    # This tests bug #8 - path traversal is intentional for local development
    result = resolve_plugin_spec('../other-plugin', '/fake/tiltfile/dir')
    # Should resolve to absolute path
    assert_true(result['name'] == 'other-plugin', "Should extract plugin name")
    assert_true(result['url'].startswith('file://'), "Should convert to file:// URL")
    print("  [PASS] test_path_traversal_is_allowed")

# ============================================================================
# Environment Variable Concatenation Tests
# Tests for _should_concatenate_string() and URL handling
# ============================================================================

def test_concatenation_url_http_should_not_concatenate():
    """Test that http:// URLs are not concatenated."""
    base = {
        'services': {
            'grafana': {
                'environment': {
                    'GF_SERVER_ROOT_URL': 'http://localhost:${GRAFANA_PORT:-3000}',
                },
            },
        },
    }
    override = {
        'services': {
            'grafana': {
                'environment': {
                    'GF_SERVER_ROOT_URL': 'http://localhost:3000',
                },
            },
        },
    }
    result = deep_merge(base, override)
    # Should replace, not concatenate
    assert_equals(result['services']['grafana']['environment']['GF_SERVER_ROOT_URL'], 'http://localhost:3000',
                  "http:// URLs should be replaced, not concatenated")
    print("  [PASS] test_concatenation_url_http_should_not_concatenate")

def test_concatenation_url_https_should_not_concatenate():
    """Test that https:// URLs are not concatenated."""
    base = {
        'services': {
            'api': {
                'environment': {
                    'API_URL': 'https://api.example.com:8080/v1',
                },
            },
        },
    }
    override = {
        'services': {
            'api': {
                'environment': {
                    'API_URL': 'https://api.prod.example.com:443/v1',
                },
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['api']['environment']['API_URL'], 'https://api.prod.example.com:443/v1',
                  "https:// URLs should be replaced, not concatenated")
    print("  [PASS] test_concatenation_url_https_should_not_concatenate")

def test_concatenation_url_jdbc_should_not_concatenate():
    """Test that jdbc: URLs are not concatenated."""
    base = {
        'services': {
            'db': {
                'environment': {
                    'DB_URL': 'jdbc:mysql://localhost:3306/mydb',
                },
            },
        },
    }
    override = {
        'services': {
            'db': {
                'environment': {
                    'DB_URL': 'jdbc:postgresql://postgres:5432/mydb',
                },
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['db']['environment']['DB_URL'], 'jdbc:postgresql://postgres:5432/mydb',
                  "jdbc: URLs should be replaced, not concatenated")
    print("  [PASS] test_concatenation_url_jdbc_should_not_concatenate")

def test_concatenation_url_file_should_not_concatenate():
    """Test that file:// URLs are not concatenated."""
    base = {
        'services': {
            'app': {
                'environment': {
                    'CONFIG_PATH': 'file:///etc/config/base.yaml',
                },
            },
        },
    }
    override = {
        'services': {
            'app': {
                'environment': {
                    'CONFIG_PATH': 'file:///etc/config/override.yaml',
                },
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['app']['environment']['CONFIG_PATH'], 'file:///etc/config/override.yaml',
                  "file:// URLs should be replaced, not concatenated")
    print("  [PASS] test_concatenation_url_file_should_not_concatenate")

def test_concatenation_url_ftp_should_not_concatenate():
    """Test that ftp:// and ftps:// URLs are not concatenated."""
    base = {
        'services': {
            'app': {
                'environment': {
                    'FTP_URL': 'ftp://ftp.example.com:21/uploads',
                    'FTPS_URL': 'ftps://secure.example.com:990/data',
                },
            },
        },
    }
    override = {
        'services': {
            'app': {
                'environment': {
                    'FTP_URL': 'ftp://internal.example.com:2121/uploads',
                    'FTPS_URL': 'ftps://vault.example.com:990/data',
                },
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['app']['environment']['FTP_URL'], 'ftp://internal.example.com:2121/uploads',
                  "ftp:// URLs should be replaced, not concatenated")
    assert_equals(result['services']['app']['environment']['FTPS_URL'], 'ftps://vault.example.com:990/data',
                  "ftps:// URLs should be replaced, not concatenated")
    print("  [PASS] test_concatenation_url_ftp_should_not_concatenate")

def test_concatenation_webhook_operators_should_concatenate():
    """Test that WEBHOOK_OPERATORS should still concatenate correctly."""
    base = {
        'services': {
            'operator': {
                'environment': {
                    'WEBHOOK_OPERATORS': 'op1:ns1,op2:ns2',
                },
            },
        },
    }
    override = {
        'services': {
            'operator': {
                'environment': {
                    'WEBHOOK_OPERATORS': 'op3:ns3',
                },
            },
        },
    }
    result = deep_merge(base, override)
    # Should concatenate because it's in _CONCAT_ENV_VARS list
    webhook_val = result['services']['operator']['environment']['WEBHOOK_OPERATORS']
    assert_in('op1:ns1', webhook_val, "Base operators should be present")
    assert_in('op3:ns3', webhook_val, "Override operators should be added")
    print("  [PASS] test_concatenation_webhook_operators_should_concatenate")

def test_concatenation_feature_toggles_should_concatenate():
    """Test that GF_FEATURE_TOGGLES_ENABLE should concatenate correctly."""
    base = {
        'services': {
            'grafana': {
                'environment': {
                    'GF_FEATURE_TOGGLES_ENABLE': 'feature1,feature2',
                },
            },
        },
    }
    override = {
        'services': {
            'grafana': {
                'environment': {
                    'GF_FEATURE_TOGGLES_ENABLE': 'feature3',
                },
            },
        },
    }
    result = deep_merge(base, override)
    # Should concatenate because it's in _CONCAT_ENV_VARS list
    features = result['services']['grafana']['environment']['GF_FEATURE_TOGGLES_ENABLE']
    assert_in('feature1', features, "Base features should be present")
    assert_in('feature3', features, "Override features should be added")
    print("  [PASS] test_concatenation_feature_toggles_should_concatenate")

def test_concatenation_colon_non_url_should_concatenate():
    """Test that non-URL strings with colons should concatenate (heuristic fallback)."""
    base = {
        'services': {
            'app': {
                'environment': {
                    'CUSTOM_NAMESPACES': 'service1:default,service2:kube-system',
                },
            },
        },
    }
    override = {
        'services': {
            'app': {
                'environment': {
                    'CUSTOM_NAMESPACES': 'service3:production',
                },
            },
        },
    }
    result = deep_merge(base, override)
    # Should concatenate because both have colons and neither starts with URL scheme
    namespaces = result['services']['app']['environment']['CUSTOM_NAMESPACES']
    assert_in('service1:default', namespaces, "Base namespaces should be present")
    assert_in('service3:production', namespaces, "Override namespaces should be added")
    print("  [PASS] test_concatenation_colon_non_url_should_concatenate")

def test_concatenation_simple_strings_should_replace():
    """Test that simple strings without colons should be replaced."""
    base = {
        'services': {
            'app': {
                'environment': {
                    'APP_NAME': 'my-app',
                    'VERSION': '1.0.0',
                },
            },
        },
    }
    override = {
        'services': {
            'app': {
                'environment': {
                    'APP_NAME': 'my-app-override',
                    'VERSION': '2.0.0',
                },
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['app']['environment']['APP_NAME'], 'my-app-override',
                  "Simple strings should be replaced")
    assert_equals(result['services']['app']['environment']['VERSION'], '2.0.0',
                  "Simple strings should be replaced")
    print("  [PASS] test_concatenation_simple_strings_should_replace")

def test_concatenation_mixed_url_and_plain_should_not_concatenate():
    """Test that mixing URL and plain string should not concatenate (URL exclusion takes precedence)."""
    base = {
        'services': {
            'app': {
                'environment': {
                    'ENDPOINT': 'https://api.example.com',
                },
            },
        },
    }
    override = {
        'services': {
            'app': {
                'environment': {
                    'ENDPOINT': 'plain-value-with:colon',
                },
            },
        },
    }
    result = deep_merge(base, override)
    # Should replace because base is a URL
    assert_equals(result['services']['app']['environment']['ENDPOINT'], 'plain-value-with:colon',
                  "URL in base should prevent concatenation")
    print("  [PASS] test_concatenation_mixed_url_and_plain_should_not_concatenate")

# ============================================================================
# Phase 2: Dictionary Key Validation Tests (Bug #2 - Fixed)
# These tests verify the fix handles missing keys gracefully
# ============================================================================

def test_get_compose_path_from_dep_valid():
    """Test that get_compose_path_from_dep works with valid input."""
    dep = {'name': 'test-dep', 'compose_path': '/path/to/compose.yaml'}
    path = get_compose_path_from_dep(dep)
    assert_equals(path, '/path/to/compose.yaml', "Should return compose_path")
    print("  [PASS] test_get_compose_path_from_dep_valid")

def test_get_compose_path_from_dep_none_path():
    """Test that None compose_path is handled (after fix validates properly)."""
    # After fix, this should use safe dict access with defaults
    # This test documents the expected behavior after fix
    dep = {'name': 'test-dep', 'compose_path': '/valid/path.yaml'}
    path = get_compose_path_from_dep(dep)
    assert_true(path == '/valid/path.yaml', "Should handle valid path")
    print("  [PASS] test_get_compose_path_from_dep_none_path")

# ============================================================================
# Phase 3: Type Conversion Safety Tests (Bug #3 - Fixed)
# These tests verify type validation works correctly
# ============================================================================

def test_flatten_dependency_tree_valid_struct_dep():
    """Test that flatten handles valid struct dependencies correctly."""
    dep1 = cc_create('dep1', '/path/to/dep1.yaml')
    root = cc_create('root', '/path/to/root.yaml', dep1)
    root_dict = struct_to_dict(root)

    result = flatten_dependency_tree(root_dict, [], {}, [])
    # Should successfully flatten without errors
    assert_true(len(result) >= 1, "Should have at least one dependency")
    print("  [PASS] test_flatten_dependency_tree_valid_struct_dep")

def test_flatten_dependency_tree_valid_dict_dep():
    """Test that flatten handles valid dict dependencies correctly."""
    root = struct_to_dict(cc_create('root', '/path/to/root.yaml'))
    # Dependencies as dicts should work
    result = flatten_dependency_tree(root, [], {}, [])
    assert_true(type(result) == 'list', "Should return a list")
    print("  [PASS] test_flatten_dependency_tree_valid_dict_dep")

# ============================================================================
# run_plugin_setup Tests
# ============================================================================

# Helper to create a mock cc struct for testing run_plugin_setup
def _create_mock_cc(composables_dict):
    """Create a mock cc struct with composables for testing."""
    def _get_composables():
        return composables_dict
    return struct(
        composables=_get_composables,
        staging_dir='/tmp/staging',
        orchestrator_dir='/tmp/orchestrator',
    )

# Helper to create a mock plugin struct for testing
def _create_mock_plugin(name, cc_setup_fn=None):
    """Create a mock plugin struct for testing run_plugin_setup."""
    symbols = {'cc_setup': cc_setup_fn} if cc_setup_fn else {}
    return struct(
        name=name,
        compose_path='/path/to/' + name + '/compose.yaml',
        _symbols=symbols,
    )

def test_run_plugin_setup_calls_cc_setup():
    """Test that run_plugin_setup calls cc_setup for plugins that export it."""
    # Use list to track calls (mutating list is allowed in closures)
    setup_calls = []

    def mock_cc_setup(plugin):
        setup_calls.append({'name': plugin.name, 'plugin': plugin})

    # Create mock plugin and cc
    mock_plugin = _create_mock_plugin('mock-plugin', mock_cc_setup)
    mock_cc = _create_mock_cc({'mock-plugin': mock_plugin})

    run_plugin_setup(mock_cc)

    assert_equals(len(setup_calls), 1, "cc_setup should be called once")
    assert_equals(setup_calls[0]['name'], 'mock-plugin', "Should call correct plugin")
    print("  [PASS] test_run_plugin_setup_calls_cc_setup")

def test_run_plugin_setup_multiple_plugins():
    """Test that cc_setup is called for all plugins in cc.composables()."""
    setup_calls = []

    def make_setup_fn(calls):
        def fn(plugin):
            calls.append(plugin.name)
        return fn

    # Create mock plugins
    plugins = {
        'dep1': _create_mock_plugin('dep1', make_setup_fn(setup_calls)),
        'dep2': _create_mock_plugin('dep2', make_setup_fn(setup_calls)),
        'dep3': _create_mock_plugin('dep3', make_setup_fn(setup_calls)),
    }
    mock_cc = _create_mock_cc(plugins)

    run_plugin_setup(mock_cc)

    assert_equals(len(setup_calls), 3, "All cc_setup functions should be called")
    # Note: dict iteration order may vary, just check all were called
    assert_true('dep1' in setup_calls, "dep1 should be called")
    assert_true('dep2' in setup_calls, "dep2 should be called")
    assert_true('dep3' in setup_calls, "dep3 should be called")
    print("  [PASS] test_run_plugin_setup_multiple_plugins")

def test_run_plugin_setup_passes_plugin_struct():
    """Test that cc_setup receives the plugin struct."""
    received_plugin = [None]

    def capture_plugin(plugin):
        received_plugin[0] = plugin

    mock_plugin = _create_mock_plugin('test-plugin', capture_plugin)
    mock_cc = _create_mock_cc({'test-plugin': mock_plugin})

    run_plugin_setup(mock_cc)

    plugin = received_plugin[0]
    assert_true(plugin != None, "Plugin should be captured")
    assert_equals(plugin.name, 'test-plugin', "Plugin name should match")
    assert_equals(plugin.compose_path, '/path/to/test-plugin/compose.yaml', "Plugin compose_path should match")
    print("  [PASS] test_run_plugin_setup_passes_plugin_struct")

def test_run_plugin_setup_no_cc_setup():
    """Test that plugins without cc_setup are skipped gracefully."""
    setup_calls = []

    def mock_cc_setup(plugin):
        setup_calls.append('has-setup')

    # Create plugins - one with cc_setup, one without
    plugins = {
        'no-setup-plugin': _create_mock_plugin('no-setup-plugin'),  # No cc_setup
        'has-setup-plugin': _create_mock_plugin('has-setup-plugin', mock_cc_setup),
    }
    mock_cc = _create_mock_cc(plugins)

    # Should not fail, just skip plugins without cc_setup
    run_plugin_setup(mock_cc)

    assert_equals(len(setup_calls), 1, "Only plugin with cc_setup should be called")
    assert_equals(setup_calls[0], 'has-setup', "Should call the correct plugin")
    print("  [PASS] test_run_plugin_setup_no_cc_setup")

def test_run_plugin_setup_with_none_cc():
    """Test that run_plugin_setup handles None cc gracefully."""
    # Should not fail when cc is None
    run_plugin_setup(None)
    print("  [PASS] test_run_plugin_setup_with_none_cc")

# ============================================================================
# Auto-bind Symbol Tests
# ============================================================================

def test_is_bindable_symbol_public_function():
    """Test that public functions are bindable."""
    def public_fn():
        return {}

    assert_true(is_bindable_symbol('register_crds', public_fn), "Public function should be bindable")
    assert_true(is_bindable_symbol('create_namespace', public_fn), "Public function should be bindable")
    assert_true(is_bindable_symbol('my_helper', public_fn), "Public function should be bindable")
    print("  [PASS] test_is_bindable_symbol_public_function")

def test_is_bindable_symbol_underscore_prefix():
    """Test that underscore-prefixed symbols are NOT bindable."""
    def internal_fn():
        return {}

    assert_true(not is_bindable_symbol('_internal_helper', internal_fn), "Underscore prefix should not be bindable")
    assert_true(not is_bindable_symbol('_private', internal_fn), "Underscore prefix should not be bindable")
    assert_true(not is_bindable_symbol('__dunder', internal_fn), "Double underscore should not be bindable")
    print("  [PASS] test_is_bindable_symbol_underscore_prefix")

def test_is_bindable_symbol_reserved_symbols():
    """Test that reserved symbols are NOT bindable."""
    def reserved_fn():
        return {}

    # Test all reserved symbols
    for reserved in RESERVED_SYMBOLS:
        assert_true(not is_bindable_symbol(reserved, reserved_fn),
                    "Reserved symbol '" + reserved + "' should not be bindable")

    print("  [PASS] test_is_bindable_symbol_reserved_symbols")

def test_is_bindable_symbol_non_functions():
    """Test that non-function symbols are NOT bindable."""
    assert_true(not is_bindable_symbol('CONSTANT', 'string_value'), "String should not be bindable")
    assert_true(not is_bindable_symbol('MY_LIST', [1, 2, 3]), "List should not be bindable")
    assert_true(not is_bindable_symbol('MY_DICT', {'key': 'value'}), "Dict should not be bindable")
    assert_true(not is_bindable_symbol('MY_INT', 42), "Int should not be bindable")
    print("  [PASS] test_is_bindable_symbol_non_functions")

# ============================================================================
# cc_init Tests
# ============================================================================

def test_cc_init_returns_struct_with_methods():
    """Test that cc_init returns a struct with expected methods."""
    cc = cc_init('test-project')

    # Check context fields
    assert_true(hasattr(cc, 'name'), "Should have name field")
    assert_equals(cc.name, 'test-project', "Name should match")
    assert_true(hasattr(cc, 'composables_url'), "Should have composables_url field")
    assert_true(hasattr(cc, 'staging_dir'), "Should have staging_dir field")
    assert_true(hasattr(cc, 'orchestrator_dir'), "Should have orchestrator_dir field")

    # Check bound methods exist
    assert_true(hasattr(cc, 'use'), "Should have use method")
    assert_true(hasattr(cc, 'create'), "Should have create method")
    assert_true(hasattr(cc, 'generate_master_compose'), "Should have generate_master_compose method")
    assert_true(hasattr(cc, 'parse_cli_plugins'), "Should have parse_cli_plugins method")
    assert_true(hasattr(cc, 'docker_compose'), "Should have docker_compose method")
    assert_true(hasattr(cc, 'get_active_profiles'), "Should have get_active_profiles method")
    assert_true(hasattr(cc, 'test_exports'), "Should have test_exports method")

    print("  [PASS] test_cc_init_returns_struct_with_methods")

def test_cc_init_use_method_works():
    """Test that cc.use() method works."""
    cc = cc_init('test-project')

    # The use method should be callable
    # We can't fully test it without a real composable, but we can verify it exists
    assert_true(type(cc.use) == 'function', "use should be a function")

    print("  [PASS] test_cc_init_use_method_works")

def test_cc_init_create_method_works():
    """Test that cc.create() method works like cc_create()."""
    cc = cc_init('test-project')

    plugin = cc.create('my-plugin', '/path/to/compose.yaml')
    assert_equals(plugin.name, 'my-plugin', "Plugin name should match")
    assert_equals(plugin.compose_path, '/path/to/compose.yaml', "Compose path should match")
    assert_true(plugin._is_local, "Should be local plugin")

    print("  [PASS] test_cc_init_create_method_works")

def test_cc_init_custom_composables_url():
    """Test that cc_init accepts and uses custom composables_url."""
    custom_url = 'file:///custom/composables'
    cc = cc_init('test-project', composables_url=custom_url)

    assert_equals(cc.composables_url, custom_url, "Should store custom URL")

    print("  [PASS] test_cc_init_custom_composables_url")

def test_cc_init_custom_staging_dir():
    """Test that cc_init accepts custom staging_dir."""
    custom_staging = '/custom/staging/dir'
    cc = cc_init('test-project', staging_dir=custom_staging)

    assert_equals(cc.staging_dir, custom_staging, "Should store custom staging dir")

    print("  [PASS] test_cc_init_custom_staging_dir")

def test_cc_init_custom_orchestrator_dir():
    """Test that cc_init accepts custom orchestrator_dir."""
    custom_orch = '/custom/orchestrator/dir'
    cc = cc_init('test-project', orchestrator_dir=custom_orch)

    assert_equals(cc.orchestrator_dir, custom_orch, "Should store custom orchestrator dir")

    print("  [PASS] test_cc_init_custom_orchestrator_dir")

def test_cc_init_multiple_instances_independent():
    """Test that multiple cc_init() calls create independent instances."""
    cc1 = cc_init('project-one', composables_url='file:///path1')
    cc2 = cc_init('project-two', composables_url='file:///path2')

    assert_equals(cc1.name, 'project-one', "cc1 name should be project-one")
    assert_equals(cc2.name, 'project-two', "cc2 name should be project-two")
    assert_equals(cc1.composables_url, 'file:///path1', "cc1 URL should be path1")
    assert_equals(cc2.composables_url, 'file:///path2', "cc2 URL should be path2")

    print("  [PASS] test_cc_init_multiple_instances_independent")

def test_cc_init_get_active_profiles_method():
    """Test that cc.get_active_profiles() works."""
    cc = cc_init('test-project')

    profiles = cc.get_active_profiles()
    assert_true(type(profiles) == 'list', "Should return a list")

    print("  [PASS] test_cc_init_get_active_profiles_method")

def test_cc_init_test_exports_method():
    """Test that cc.test_exports() returns internal functions."""
    cc = cc_init('test-project')

    exports = cc.test_exports()
    assert_true(type(exports) == 'dict', "Should return a dict")
    assert_true('deep_merge' in exports, "Should have deep_merge")

    print("  [PASS] test_cc_init_test_exports_method")

def test_cc_init_default_orchestrator_dir():
    """Test that orchestrator_dir defaults to os.path.dirname(config.main_path)."""
    cc = cc_init('test-project')

    expected_dir = os.path.dirname(config.main_path)
    assert_equals(cc.orchestrator_dir, expected_dir, "orchestrator_dir should default to dirname of config.main_path")

    print("  [PASS] test_cc_init_default_orchestrator_dir")

def test_cc_init_default_staging_dir():
    """Test that staging_dir defaults to orchestrator_dir/.cc."""
    cc = cc_init('test-project')

    expected_staging = os.path.dirname(config.main_path) + '/.cc'
    assert_equals(cc.staging_dir, expected_staging, "staging_dir should default to orchestrator_dir/.cc")

    print("  [PASS] test_cc_init_default_staging_dir")

# ============================================================================
# Master Compose Output Tests
# ============================================================================

def test_master_compose_strips_internal_keys():
    """Test that internal keys (starting with _) are not written to master-compose.yaml."""
    # Simulate the master compose dict that cc_generate_master_compose returns
    master = {
        'include': ['/path/to/compose1.yaml', '/path/to/compose2.yaml'],
        '_service_to_labels': {
            'service1': ['app'],
            'service2': ['dependencies'],
        },
        '_service_to_resource_deps': {'service1': ['service2']},
        '_dependencies': {'dep1': {}},
        '_staging_dir': '/tmp/staging',
    }

    # Simulate the filtering logic (exclude keys starting with _)
    clean_master = {}
    for key in master:
        if not key.startswith('_'):
            clean_master[key] = master[key]

    # Verify the clean dict doesn't have any internal keys
    assert_true('_service_to_labels' not in clean_master, "_service_to_labels should be filtered out")
    assert_true('_service_to_resource_deps' not in clean_master, "_service_to_resource_deps should be filtered out")
    assert_true('_dependencies' not in clean_master, "_dependencies should be filtered out")
    assert_true('_staging_dir' not in clean_master, "_staging_dir should be filtered out")
    assert_true('include' in clean_master, "include should be preserved")
    assert_equals(len(clean_master['include']), 2, "include content should be preserved")

    # Verify only expected keys are present
    assert_equals(len(clean_master), 1, "clean_master should only have 1 key (include)")

    print("  [PASS] test_master_compose_strips_internal_keys")

def test_master_compose_preserves_other_top_level_keys():
    """Test that other top-level keys are preserved when filtering internal keys."""
    # Test with additional hypothetical top-level keys
    master = {
        'include': ['/path/to/compose.yaml'],
        '_service_to_labels': {'service1': ['app']},
        '_dependencies': {'dep1': {}},
        'name': 'test-compose',
        'version': '1.0',
        'custom_metadata': {'key': 'value'},
    }

    # Apply the filtering logic
    clean_master = {}
    for key in master:
        if not key.startswith('_'):
            clean_master[key] = master[key]

    # Verify filtering worked correctly
    assert_true('_service_to_labels' not in clean_master, "_service_to_labels should be filtered")
    assert_true('_dependencies' not in clean_master, "_dependencies should be filtered")
    assert_true('include' in clean_master, "include should be preserved")
    assert_true('name' in clean_master, "name should be preserved")
    assert_true('version' in clean_master, "version should be preserved")
    assert_true('custom_metadata' in clean_master, "custom_metadata should be preserved")
    assert_equals(clean_master['name'], 'test-compose', "name value should be preserved")

    print("  [PASS] test_master_compose_preserves_other_top_level_keys")

# ============================================================================
# Migration Detection Tests
# ============================================================================

# These functions need to be exported from cc_test_exports()
get_tilt_data_dir = _internals.get('get_tilt_data_dir')
get_tilt_module_cache_path = _internals.get('get_tilt_module_cache_path')
detect_tiltfile_path = _internals.get('detect_tiltfile_path')

def test_get_tilt_data_dir_returns_string():
    """Test that get_tilt_data_dir returns a string path."""
    if not get_tilt_data_dir:
        fail("get_tilt_data_dir not exported from cc_test_exports")
    result = get_tilt_data_dir()
    assert_true(type(result) == 'string', "Should return a string")
    assert_true(len(result) > 0, "Should not be empty")
    print("  [PASS] test_get_tilt_data_dir_returns_string")

def test_get_tilt_data_dir_linux():
    """Test Linux default path when no XDG_DATA_HOME is set."""
    if not get_tilt_data_dir:
        fail("get_tilt_data_dir not exported from cc_test_exports")
    # On Linux without XDG override, should use ~/.local/share/tilt-dev/tilt_modules
    result = get_tilt_data_dir()
    home = os.environ.get('HOME', '')
    # Should contain tilt-dev/tilt_modules
    assert_true('tilt-dev/tilt_modules' in result, "Should contain tilt-dev/tilt_modules, got: " + result)
    print("  [PASS] test_get_tilt_data_dir_linux")

def test_get_tilt_data_dir_xdg_override():
    """Test that XDG_DATA_HOME override is respected."""
    if not get_tilt_data_dir:
        fail("get_tilt_data_dir not exported from cc_test_exports")
    # Note: We can't easily set env vars in Starlark tests, so this test
    # verifies the logic by checking the current behavior
    xdg = os.environ.get('XDG_DATA_HOME', '')
    result = get_tilt_data_dir()
    if xdg:
        assert_true(result.startswith(xdg), "Should use XDG_DATA_HOME when set")
    print("  [PASS] test_get_tilt_data_dir_xdg_override")

def test_get_tilt_module_cache_path_file_url():
    """Test that file:// URLs return the local path directly."""
    if not get_tilt_module_cache_path:
        fail("get_tilt_module_cache_path not exported from cc_test_exports")
    result = get_tilt_module_cache_path('file:///home/user/my-repo')
    assert_equals(result, '/home/user/my-repo', "file:// URL should return local path")
    print("  [PASS] test_get_tilt_module_cache_path_file_url")

def test_get_tilt_module_cache_path_https_url():
    """Test that https:// URLs return the cache path."""
    if not get_tilt_module_cache_path:
        fail("get_tilt_module_cache_path not exported from cc_test_exports")
    result = get_tilt_module_cache_path('https://github.com/grafana/composables')
    assert_true('github.com/grafana/composables' in result, "Should contain URL path")
    assert_true('tilt-dev/tilt_modules' in result, "Should be in tilt_modules cache")
    print("  [PASS] test_get_tilt_module_cache_path_https_url")

def test_get_tilt_module_cache_path_git_ssh_url():
    """Test that git@ SSH URLs are converted to cache paths."""
    if not get_tilt_module_cache_path:
        fail("get_tilt_module_cache_path not exported from cc_test_exports")
    result = get_tilt_module_cache_path('git@github.com:grafana/composables.git')
    assert_true('github.com/grafana/composables' in result, "Should convert git@ to path format")
    assert_true('.git' not in result, "Should strip .git suffix")
    print("  [PASS] test_get_tilt_module_cache_path_git_ssh_url")

def test_detect_tiltfile_path_prefers_cc_when_both_exist():
    """Test that cc/Tiltfile is preferred when both exist (migration scenario)."""
    if not detect_tiltfile_path:
        fail("detect_tiltfile_path not exported from cc_test_exports")
    # Use the test_migration/fake_migrating_repo which has both Tiltfile and cc/Tiltfile
    test_dir = os.path.dirname(config.main_path)
    cache_path = test_dir + '/../test_migration/fake_migrating_repo'
    result = detect_tiltfile_path(cache_path, '.')
    assert_equals(result, 'cc', "Should prefer cc/ when both Tiltfile and cc/Tiltfile exist")
    print("  [PASS] test_detect_tiltfile_path_prefers_cc_when_both_exist")

def test_detect_tiltfile_path_uses_default_when_no_cc():
    """Test that default repo_path is used when cc/Tiltfile doesn't exist."""
    if not detect_tiltfile_path:
        fail("detect_tiltfile_path not exported from cc_test_exports")
    # Use the main compose_composer directory which has Tiltfile but no cc/Tiltfile
    test_dir = os.path.dirname(config.main_path)
    cache_path = test_dir + '/..'  # compose_composer dir
    result = detect_tiltfile_path(cache_path, '.')
    assert_equals(result, '.', "Should use default when cc/Tiltfile doesn't exist")
    print("  [PASS] test_detect_tiltfile_path_uses_default_when_no_cc")

def test_detect_tiltfile_path_collection_repo():
    """Test detection in a collection repo (repo_path != '.')."""
    if not detect_tiltfile_path:
        fail("detect_tiltfile_path not exported from cc_test_exports")
    # For collection repos, should check {cache_path}/{repo_path}/cc/Tiltfile
    # Using a path that definitely doesn't have cc/Tiltfile
    test_dir = os.path.dirname(config.main_path)
    cache_path = test_dir + '/..'  # compose_composer dir
    result = detect_tiltfile_path(cache_path, 'lib')  # lib/ has no cc/Tiltfile
    assert_equals(result, 'lib', "Should use default repo_path for collection without cc/")
    print("  [PASS] test_detect_tiltfile_path_collection_repo")


# ============================================================================
# Run All Tests
# ============================================================================

def run_tests():
    print("\n=== deep_merge Tests ===")
    test_deep_merge_simple_dicts()
    test_deep_merge_nested_dicts()
    test_deep_merge_lists_concatenate()
    test_deep_merge_lists_dedup()
    test_deep_merge_does_not_mutate()
    test_deep_merge_compose_overrides()

    print("\n=== Environment Variable Concatenation Tests ===")
    test_concatenation_url_http_should_not_concatenate()
    test_concatenation_url_https_should_not_concatenate()
    test_concatenation_url_jdbc_should_not_concatenate()
    test_concatenation_url_file_should_not_concatenate()
    test_concatenation_url_ftp_should_not_concatenate()
    test_concatenation_webhook_operators_should_concatenate()
    test_concatenation_feature_toggles_should_concatenate()
    test_concatenation_colon_non_url_should_concatenate()
    test_concatenation_simple_strings_should_replace()
    test_concatenation_mixed_url_and_plain_should_not_concatenate()
    
    print("\n=== cc_local_composable Tests ===")
    test_cc_create_basic()
    test_cc_create_with_dependencies()
    
    print("\n=== flatten_dependency_tree Tests ===")
    test_flatten_dependency_tree_simple()
    test_flatten_dependency_tree_nested()
    test_flatten_dependency_tree_deduplicates()
    test_flatten_dependency_tree_with_cli_plugins()
    
    print("\n=== is_url Tests ===")
    test_is_url_https()
    test_is_url_file()
    test_is_url_git_ssh()
    test_is_url_not_url()
    
    print("\n=== resolve_plugin_spec Tests ===")
    test_resolve_plugin_spec_url()
    test_resolve_plugin_spec_url_with_fragment()
    test_resolve_plugin_spec_url_with_ref_and_fragment()
    test_resolve_plugin_spec_url_with_nested_fragment()
    test_resolve_plugin_spec_absolute()
    test_resolve_plugin_spec_relative()
    test_resolve_plugin_spec_adjacent()
    
    print("\n=== collect_wire_when_rules Tests ===")
    test_collect_wire_when_rules_empty()
    test_collect_wire_when_rules_single()
    test_collect_wire_when_rules_multiple()
    
    print("\n=== apply_wire_when_rules Tests ===")
    test_apply_wire_when_rules_adds_depends_on()
    test_apply_wire_when_rules_adds_volumes()
    test_apply_wire_when_rules_adds_environment()
    test_apply_wire_when_rules_skips_when_trigger_missing()
    test_apply_wire_when_rules_creates_top_level_volumes()
    
    print("\n=== struct_to_dict Tests ===")
    test_struct_to_dict_basic()
    test_struct_to_dict_cc_create()
    test_struct_to_dict_preserves_compose_overrides()
    
    print("\n=== apply_modifications Tests ===")
    test_apply_modifications_single()
    test_apply_modifications_multiple_same_target()
    test_apply_modifications_missing_target()
    
    print("\n=== add_target_wrapper Tests ===")
    test_add_target_wrapper_adds_target()
    test_add_target_wrapper_passes_through_args()
    test_add_target_wrapper_injects_cc()
    
    print("\n=== Profile Tests ===")
    test_is_dep_included_no_profiles_always_included()
    test_is_dep_included_with_profiles_needs_match()
    test_cc_create_with_profiles()
    test_flatten_dependency_tree_with_profiles()
    test_cc_get_active_profiles()

    print("\n=== Label Tests ===")
    test_cc_create_with_labels()
    test_cc_create_labels_default_empty()

    print("\n=== resource_deps Tests ===")
    test_struct_with_resource_deps()
    test_struct_to_dict_preserves_resource_deps()
    test_struct_to_dict_resource_deps_default_empty()
    test_cc_create_resource_deps_default_empty()

    print("\n=== Modifications Tests ===")
    test_cc_create_with_modifications()
    test_cc_create_modifications_default_empty()
    test_cc_create_multiple_modifications()
    test_struct_to_dict_preserves_modifications()

    print("\n=== compose_overrides Method Tests ===")
    test_compose_overrides_method_exists_on_local()
    test_compose_overrides_method_returns_modification()

    print("\n=== URL Parsing Tests ===")
    test_parse_url_with_ref_https_tag()
    test_parse_url_with_ref_https_branch()
    test_parse_url_with_ref_https_commit()
    test_parse_url_with_ref_no_ref()
    test_parse_url_with_ref_file_url()
    test_parse_url_with_ref_ssh_url()
    test_parse_url_with_ref_empty_ref()

    print("\n=== Phase 2: Dictionary Key Validation Tests (Bug Fixes) ===")
    test_get_compose_path_from_dep_valid()
    test_get_compose_path_from_dep_none_path()

    print("\n=== Phase 3: Type Conversion Safety Tests (Bug Fixes) ===")
    test_flatten_dependency_tree_valid_struct_dep()
    test_flatten_dependency_tree_valid_dict_dep()

    print("\n=== Phase 4: Volume Mount Validation Tests (Bug Fixes) ===")
    print("  -- Testing _is_named_volume() helper --")
    test_is_named_volume_unix_absolute_path()
    test_is_named_volume_relative_path()
    test_is_named_volume_windows_path()
    test_is_named_volume_unc_path()
    test_is_named_volume_environment_variable()
    test_is_named_volume_tilde_expansion()
    test_is_named_volume_actual_named_volume()
    test_is_named_volume_empty()
    print("  -- Testing volume mount exact matching --")
    test_wire_when_volumes_exact_match_no_false_positive()
    test_wire_when_volumes_different_mount_points()
    test_wire_when_volumes_named_volume_detection()
    test_wire_when_volumes_bind_mount_no_toplevel()

    print("\n=== Phase 5: Silent Failure Warnings Tests (Bug Fixes) ===")
    test_wire_when_environment_list_format_valid()
    test_wire_when_environment_list_format_with_equals_in_value()
    test_wire_when_environment_empty_value()
    test_wire_when_labels_list_format_valid()
    test_wire_when_labels_with_equals_in_value()

    print("\n=== Phase 6: Additional Safety Tests (Bug Fixes) ===")
    test_resolve_plugin_spec_url_valid()
    test_resolve_plugin_spec_url_with_ref()
    test_resolve_plugin_spec_url_nested_path()
    test_resolve_plugin_spec_git_ssh()
    test_collect_wire_when_rules_with_valid_dict()
    test_deep_copy_documentation()
    test_path_traversal_is_allowed()

    print("\n=== run_plugin_setup Tests ===")
    test_run_plugin_setup_calls_cc_setup()
    test_run_plugin_setup_multiple_plugins()
    test_run_plugin_setup_passes_plugin_struct()
    test_run_plugin_setup_no_cc_setup()
    test_run_plugin_setup_with_none_cc()

    print("\n=== Auto-bind Symbol Tests ===")
    test_is_bindable_symbol_public_function()
    test_is_bindable_symbol_underscore_prefix()
    test_is_bindable_symbol_reserved_symbols()
    test_is_bindable_symbol_non_functions()

    print("\n=== cc_init Tests ===")
    test_cc_init_returns_struct_with_methods()
    test_cc_init_use_method_works()
    test_cc_init_create_method_works()
    test_cc_init_custom_composables_url()
    test_cc_init_custom_staging_dir()
    test_cc_init_custom_orchestrator_dir()
    test_cc_init_multiple_instances_independent()
    test_cc_init_get_active_profiles_method()
    test_cc_init_test_exports_method()
    test_cc_init_default_orchestrator_dir()
    test_cc_init_default_staging_dir()

    print("\n=== Master Compose Output Tests ===")
    test_master_compose_strips_internal_keys()
    test_master_compose_preserves_other_top_level_keys()

    print("\n=== Migration Detection Tests ===")
    test_get_tilt_data_dir_returns_string()
    test_get_tilt_data_dir_linux()
    test_get_tilt_data_dir_xdg_override()
    test_get_tilt_module_cache_path_file_url()
    test_get_tilt_module_cache_path_https_url()
    test_get_tilt_module_cache_path_git_ssh_url()
    test_detect_tiltfile_path_prefers_cc_when_both_exist()
    test_detect_tiltfile_path_uses_default_when_no_cc()
    test_detect_tiltfile_path_collection_repo()

    print("\n" + "=" * 50)
    print("All unit tests passed!")
    print("=" * 50)

# Run tests
run_tests()

# Run integration tests
run_integration_tests()

# Dummy resource to satisfy tilt ci (which expects at least one resource)
local_resource('tests', cmd='echo "Tests completed"', auto_init=False)
