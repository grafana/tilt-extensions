# Tests for compose_composer extension
# Run with: tilt ci (from this directory)
# Or: make test (from parent directory)

load('../Tiltfile', 'cc_test_exports', 'cc_composable', 'cc_local_composable', 'cc_generate_master_compose', 'cc_parse_cli_plugins', 'cc_get_active_profiles')

# Get internal functions for testing
_internals = cc_test_exports()
deep_merge = _internals['deep_merge']
deep_copy = _internals['deep_copy']
collect_wire_when_rules = _internals['collect_wire_when_rules']
apply_wire_when_rules = _internals['apply_wire_when_rules']
is_url = _internals['is_url']
resolve_plugin_spec = _internals['resolve_plugin_spec']
struct_to_dict = _internals['struct_to_dict']
apply_modifications = _internals['apply_modifications']
add_target_wrapper = _internals['add_target_wrapper']
flatten_dependency_tree = _internals['flatten_dependency_tree']
is_dep_included_by_profile = _internals['is_dep_included_by_profile']

# ============================================================================
# Test Helpers
# ============================================================================

def assert_equals(actual, expected, msg=""):
    """Assert that actual equals expected."""
    if actual != expected:
        fail_msg = "Expected '{}', got '{}'".format(expected, actual)
        if msg:
            fail_msg = msg + ": " + fail_msg
        fail(fail_msg)

def assert_true(condition, msg=""):
    """Assert that condition is true."""
    if not condition:
        fail(msg if msg else "Assertion failed")

def assert_in(item, collection, msg=""):
    """Assert that item is in collection."""
    if item not in collection:
        fail_msg = "'{}' not in '{}'".format(item, collection)
        if msg:
            fail_msg = msg + ": " + fail_msg
        fail(fail_msg)

# ============================================================================
# deep_merge Tests
# ============================================================================

def test_deep_merge_simple_dicts():
    """Test merging two simple dicts."""
    base = {'a': 1, 'b': 2}
    override = {'b': 3, 'c': 4}
    result = deep_merge(base, override)
    assert_equals(result['a'], 1, "Base value should be preserved")
    assert_equals(result['b'], 3, "Override should take precedence")
    assert_equals(result['c'], 4, "New key should be added")
    print("  [PASS] test_deep_merge_simple_dicts")

def test_deep_merge_nested_dicts():
    """Test merging nested dicts recursively."""
    base = {'outer': {'inner1': 'a', 'inner2': 'b'}}
    override = {'outer': {'inner2': 'c', 'inner3': 'd'}}
    result = deep_merge(base, override)
    assert_equals(result['outer']['inner1'], 'a', "Nested base value preserved")
    assert_equals(result['outer']['inner2'], 'c', "Nested override takes precedence")
    assert_equals(result['outer']['inner3'], 'd', "Nested new key added")
    print("  [PASS] test_deep_merge_nested_dicts")

def test_deep_merge_lists_concatenate():
    """Test that lists are concatenated, not replaced."""
    base = {'items': ['a', 'b']}
    override = {'items': ['c', 'd']}
    result = deep_merge(base, override)
    assert_equals(len(result['items']), 4, "Lists should be concatenated")
    assert_in('a', result['items'])
    assert_in('d', result['items'])
    print("  [PASS] test_deep_merge_lists_concatenate")

def test_deep_merge_lists_dedup():
    """Test that duplicate list items are not added."""
    base = {'items': ['a', 'b']}
    override = {'items': ['b', 'c']}
    result = deep_merge(base, override)
    assert_equals(len(result['items']), 3, "Duplicates should not be added")
    print("  [PASS] test_deep_merge_lists_dedup")

def test_deep_merge_does_not_mutate():
    """Test that base dict is not mutated."""
    base = {'a': 1}
    override = {'b': 2}
    result = deep_merge(base, override)
    assert_true('b' not in base, "Base should not be mutated")
    print("  [PASS] test_deep_merge_does_not_mutate")

def test_deep_merge_compose_overrides():
    """Test merging compose-like structures."""
    base = {
        'services': {
            'grafana': {
                'environment': {'VAR1': 'val1'},
                'volumes': ['/vol1:/mount1'],
            },
        },
    }
    override = {
        'services': {
            'grafana': {
                'environment': {'VAR2': 'val2'},
                'volumes': ['/vol2:/mount2'],
            },
        },
    }
    result = deep_merge(base, override)
    assert_equals(result['services']['grafana']['environment']['VAR1'], 'val1')
    assert_equals(result['services']['grafana']['environment']['VAR2'], 'val2')
    assert_equals(len(result['services']['grafana']['volumes']), 2)
    print("  [PASS] test_deep_merge_compose_overrides")

# ============================================================================
# local_compose Tests
# ============================================================================

def test_cc_local_composable_basic():
    """Test creating a basic cc_local_composable struct."""
    plugin = cc_local_composable('my-plugin', '/path/to/compose.yaml')
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.compose_path, '/path/to/compose.yaml')
    assert_equals(len(plugin.dependencies), 0)
    assert_true(plugin._is_local)
    print("  [PASS] test_cc_local_composable_basic")

def test_cc_local_composable_with_dependencies():
    """Test creating cc_local_composable with dependencies."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    dep2 = struct(
        name='dep2',
        url='file:///path',
        ref=None,
        repo_path='dep2',
        compose_path='/path/dep2.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    plugin = cc_local_composable('my-plugin', '/path/to/compose.yaml', dep1, dep2)
    assert_equals(len(plugin.dependencies), 2)
    assert_equals(plugin.dependencies[0].name, 'dep1')
    assert_equals(plugin.dependencies[1].name, 'dep2')
    print("  [PASS] test_cc_local_composable_with_dependencies")

# ============================================================================
# flatten_dependency_tree Tests
# ============================================================================

def test_flatten_dependency_tree_simple():
    """Test flattening a simple dependency tree."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_local_composable('root', '/path/root.yaml', dep1)
    result = flatten_dependency_tree(root, [])
    
    # Should have dep1 first, then root
    assert_equals(len(result), 2)
    assert_equals(result[0]['name'], 'dep1')
    assert_equals(result[1]['name'], 'root')
    print("  [PASS] test_flatten_dependency_tree_simple")

def test_flatten_dependency_tree_nested():
    """Test flattening nested dependencies."""
    dep_inner = struct(
        name='inner',
        url='file:///path',
        ref=None,
        repo_path='inner',
        compose_path='/path/inner.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep_outer = struct(
        name='outer',
        url='file:///path',
        ref=None,
        repo_path='outer',
        compose_path='/path/outer.yaml',
        compose_overrides={},
        dependencies=[dep_inner],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_local_composable('root', '/path/root.yaml', dep_outer)
    result = flatten_dependency_tree(root, [])
    
    # Should be: inner, outer, root (depth-first)
    assert_equals(len(result), 3)
    assert_equals(result[0]['name'], 'inner')
    assert_equals(result[1]['name'], 'outer')
    assert_equals(result[2]['name'], 'root')
    print("  [PASS] test_flatten_dependency_tree_nested")

def test_flatten_dependency_tree_deduplicates():
    """Test that duplicate dependencies are deduplicated."""
    shared_dep = struct(
        name='shared',
        url='file:///path',
        ref=None,
        repo_path='shared',
        compose_path='/path/shared.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        compose_overrides={},
        dependencies=[shared_dep],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dep2 = struct(
        name='dep2',
        url='file:///path',
        ref=None,
        repo_path='dep2',
        compose_path='/path/dep2.yaml',
        compose_overrides={},
        dependencies=[shared_dep],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_local_composable('root', '/path/root.yaml', dep1, dep2)
    result = flatten_dependency_tree(root, [])
    
    # Should be: shared (once), dep1, dep2, root
    names = [r['name'] for r in result]
    shared_count = len([n for n in names if n == 'shared'])
    assert_equals(shared_count, 1, "Shared dep should only appear once")
    assert_equals(len(result), 4)
    print("  [PASS] test_flatten_dependency_tree_deduplicates")

def test_flatten_dependency_tree_with_cli_plugins():
    """Test flattening with CLI plugins."""
    dep1 = struct(
        name='dep1',
        url='file:///path',
        ref=None,
        repo_path='dep1',
        compose_path='/path/dep1.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    cli_plugin = struct(
        name='cli-plugin',
        url='file:///path',
        ref=None,
        repo_path='cli-plugin',
        compose_path='/path/cli.yaml',
        compose_overrides={},
        dependencies=[],
        _symbols={},
        _from_cli=True,
        _is_local=False,
    )
    
    root = cc_local_composable('root', '/path/root.yaml', dep1)
    result = flatten_dependency_tree(root, [cli_plugin])
    
    # Should have: dep1, root, cli-plugin
    names = [r['name'] for r in result]
    assert_in('dep1', names)
    assert_in('root', names)
    assert_in('cli-plugin', names)
    print("  [PASS] test_flatten_dependency_tree_with_cli_plugins")

# ============================================================================
# is_url Tests
# ============================================================================

def test_is_url_https():
    """Test HTTPS URL detection."""
    assert_true(is_url('https://github.com/org/repo.git'), "HTTPS should be detected")
    print("  [PASS] test_is_url_https")

def test_is_url_file():
    """Test file:// URL detection."""
    assert_true(is_url('file:///path/to/dir'), "file:// should be detected")
    print("  [PASS] test_is_url_file")

def test_is_url_git_ssh():
    """Test git SSH URL detection."""
    assert_true(is_url('git@github.com:org/repo.git'), "git@ should be detected")
    print("  [PASS] test_is_url_git_ssh")

def test_is_url_not_url():
    """Test non-URL strings."""
    assert_true(not is_url('plugin-name'), "Plain name should not be URL")
    assert_true(not is_url('../relative/path'), "Relative path should not be URL")
    assert_true(not is_url('/absolute/path'), "Absolute path should not be URL")
    print("  [PASS] test_is_url_not_url")

# ============================================================================
# resolve_plugin_spec Tests
# ============================================================================

def test_resolve_plugin_spec_url():
    """Test URL passthrough."""
    result = resolve_plugin_spec('https://github.com/org/repo.git', '/base')
    assert_equals(result['url'], 'https://github.com/org/repo.git')
    assert_equals(result['name'], 'repo')
    assert_true(result['_from_cli'])
    print("  [PASS] test_resolve_plugin_spec_url")

def test_resolve_plugin_spec_absolute():
    """Test absolute path conversion to file:// URL."""
    result = resolve_plugin_spec('/absolute/path/to/plugin', '/base')
    assert_true(result['url'].startswith('file://'))
    assert_in('/absolute/path/to/plugin', result['url'])
    assert_equals(result['name'], 'plugin')
    print("  [PASS] test_resolve_plugin_spec_absolute")

def test_resolve_plugin_spec_relative():
    """Test relative path resolution."""
    result = resolve_plugin_spec('./subdir/plugin', '/base/dir')
    assert_true(result['url'].startswith('file://'))
    assert_equals(result['name'], 'plugin')
    assert_equals(result['repo_path'], '.')
    print("  [PASS] test_resolve_plugin_spec_relative")

def test_resolve_plugin_spec_adjacent():
    """Test adjacent directory (plain name) resolution."""
    result = resolve_plugin_spec('sibling-plugin', '/base/my-plugin')
    assert_true(result['url'].startswith('file://'))
    assert_equals(result['name'], 'sibling-plugin')
    print("  [PASS] test_resolve_plugin_spec_adjacent")

# ============================================================================
# collect_wire_when_rules Tests
# ============================================================================

def test_collect_wire_when_rules_empty():
    """Test with no extensions exporting wire_when."""
    deps = [
        {'name': 'dep1', 'symbols': {}},
        {'name': 'dep2', 'symbols': {'other_fn': lambda: None}},
    ]
    result = collect_wire_when_rules(deps)
    assert_equals(len(result), 0, "Should be empty when no wire_when")
    print("  [PASS] test_collect_wire_when_rules_empty")

def test_collect_wire_when_rules_single():
    """Test collecting rules from one extension."""
    def mock_wire_when():
        return {
            'k3s-apiserver': {
                'services': {
                    'grafana': {'depends_on': ['k3s-apiserver']},
                },
            },
        }
    
    deps = [
        {'name': 'grafana', 'symbols': {'get_wire_when': mock_wire_when}},
    ]
    result = collect_wire_when_rules(deps)
    assert_in('k3s-apiserver', result)
    assert_equals(len(result['k3s-apiserver']), 1)
    assert_equals(result['k3s-apiserver'][0]['source_dep'], 'grafana')
    print("  [PASS] test_collect_wire_when_rules_single")

def test_collect_wire_when_rules_multiple():
    """Test collecting rules from multiple extensions."""
    def wire_when_1():
        return {'k3s-apiserver': {'services': {'svc1': {}}}}
    
    def wire_when_2():
        return {'k3s-apiserver': {'services': {'svc2': {}}}}
    
    deps = [
        {'name': 'ext1', 'symbols': {'get_wire_when': wire_when_1}},
        {'name': 'ext2', 'symbols': {'get_wire_when': wire_when_2}},
    ]
    result = collect_wire_when_rules(deps)
    assert_in('k3s-apiserver', result)
    assert_equals(len(result['k3s-apiserver']), 2, "Should have rules from both extensions")
    print("  [PASS] test_collect_wire_when_rules_multiple")

# ============================================================================
# apply_wire_when_rules Tests
# ============================================================================

def test_apply_wire_when_rules_adds_depends_on():
    """Test that depends_on is added correctly."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'depends_on': ['k3s-apiserver']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_in('k3s-apiserver', result['services']['grafana']['depends_on'])
    print("  [PASS] test_apply_wire_when_rules_adds_depends_on")

def test_apply_wire_when_rules_adds_volumes():
    """Test that volumes are added correctly."""
    compose = {
        'services': {
            'grafana': {'volumes': ['/existing:/mount']},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'volumes': ['k3s-certs:/certs:ro']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_equals(len(result['services']['grafana']['volumes']), 2)
    print("  [PASS] test_apply_wire_when_rules_adds_volumes")

def test_apply_wire_when_rules_adds_environment():
    """Test that environment variables are added correctly."""
    compose = {
        'services': {
            'grafana': {'environment': {'EXISTING': 'value'}},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'environment': {'NEW_VAR': 'new_value'}},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_equals(result['services']['grafana']['environment']['EXISTING'], 'value')
    assert_equals(result['services']['grafana']['environment']['NEW_VAR'], 'new_value')
    print("  [PASS] test_apply_wire_when_rules_adds_environment")

def test_apply_wire_when_rules_skips_when_trigger_missing():
    """Test that rules don't apply when trigger dependency is missing."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'depends_on': ['k3s-apiserver']},
                    },
                },
            },
        ],
    }
    # k3s-apiserver is NOT in loaded_dep_names
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'mysql'])
    assert_true('depends_on' not in result['services']['grafana'], "Should not apply when trigger missing")
    print("  [PASS] test_apply_wire_when_rules_skips_when_trigger_missing")

def test_apply_wire_when_rules_creates_top_level_volumes():
    """Test that named volumes are added to top-level volumes section."""
    compose = {
        'services': {
            'grafana': {},
        },
    }
    rules = {
        'k3s-apiserver': [
            {
                'source_dep': 'grafana',
                'rules': {
                    'services': {
                        'grafana': {'volumes': ['k3s-certs:/certs:ro']},
                    },
                },
            },
        ],
    }
    result = apply_wire_when_rules(compose, 'grafana', rules, ['grafana', 'k3s-apiserver'])
    assert_in('volumes', result)
    assert_in('k3s-certs', result['volumes'])
    print("  [PASS] test_apply_wire_when_rules_creates_top_level_volumes")

# ============================================================================
# struct_to_dict Tests
# ============================================================================

def test_struct_to_dict_basic():
    """Test converting a basic struct to dict."""
    s = struct(
        name='test-dep',
        url='file:///path',
        ref=None,
        repo_path='test-dep',
        compose_path='/path/compose.yaml',
        compose_overrides={'services': {}},
        dependencies=[],
        _symbols={'fn': lambda: None},
        _from_cli=False,
        _is_local=False,
    )
    result = struct_to_dict(s)
    assert_equals(result['name'], 'test-dep')
    assert_equals(result['url'], 'file:///path')
    assert_equals(result['_from_cli'], False)
    assert_true('symbols' in result, "Should have symbols key")
    print("  [PASS] test_struct_to_dict_basic")

def test_struct_to_dict_cc_local_composable():
    """Test converting a cc_local_composable struct to dict."""
    plugin = cc_local_composable('my-plugin', '/path/to/compose.yaml')
    result = struct_to_dict(plugin)
    assert_equals(result['name'], 'my-plugin')
    assert_equals(result['compose_path'], '/path/to/compose.yaml')
    assert_true(result['_is_local'])
    print("  [PASS] test_struct_to_dict_cc_local_composable")

def test_struct_to_dict_preserves_compose_overrides():
    """Test that compose_overrides are preserved."""
    overrides = {'services': {'svc': {'environment': {'VAR': 'val'}}}}
    s = struct(
        name='test',
        url='file:///path',
        ref=None,
        repo_path='test',
        compose_path='/path/compose.yaml',
        compose_overrides=overrides,
        dependencies=[],
        _symbols={},
        _from_cli=True,
        _is_local=False,
    )
    result = struct_to_dict(s)
    assert_equals(result['compose_overrides']['services']['svc']['environment']['VAR'], 'val')
    print("  [PASS] test_struct_to_dict_preserves_compose_overrides")

# ============================================================================
# apply_modifications Tests
# ============================================================================

def test_apply_modifications_single():
    """Test applying a single modification."""
    deps = [
        {'name': 'k3s-apiserver', 'url': 'file:///path', 'compose_overrides': {}},
        {'name': 'mysql', 'url': 'file:///path', 'compose_overrides': {}},
    ]
    mods = [
        {
            '_target': 'k3s-apiserver',
            'services': {'crd-loader': {'volumes': ['/crds:/crds:ro']}},
        },
    ]
    apply_modifications(deps, mods)
    assert_in('services', deps[0]['compose_overrides'])
    assert_in('crd-loader', deps[0]['compose_overrides']['services'])
    print("  [PASS] test_apply_modifications_single")

def test_apply_modifications_multiple_same_target():
    """Test applying multiple modifications to the same target."""
    deps = [
        {'name': 'k3s-apiserver', 'url': 'file:///path', 'compose_overrides': {}},
    ]
    mods = [
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/path1:/crds/p1:ro']}}},
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/path2:/crds/p2:ro']}}},
    ]
    apply_modifications(deps, mods)
    volumes = deps[0]['compose_overrides']['services']['crd-loader']['volumes']
    assert_equals(len(volumes), 2, "Both modifications should be merged")
    print("  [PASS] test_apply_modifications_multiple_same_target")

def test_apply_modifications_missing_target():
    """Test that modifications with missing targets are skipped."""
    deps = [
        {'name': 'mysql', 'url': 'file:///path', 'compose_overrides': {}},
    ]
    mods = [
        {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['/crds:/crds:ro']}}},
    ]
    # Should not fail, just skip
    apply_modifications(deps, mods)
    assert_equals(deps[0]['compose_overrides'], {}, "Should not be modified")
    print("  [PASS] test_apply_modifications_missing_target")

# ============================================================================
# add_target_wrapper Tests
# ============================================================================

def test_add_target_wrapper_adds_target():
    """Test that wrapper adds _target to result."""
    def original_fn():
        return {'services': {'svc': {}}}
    
    wrapped = add_target_wrapper(original_fn, 'test-dep')
    result = wrapped()
    
    assert_in('_target', result)
    assert_equals(result['_target'], 'test-dep')
    print("  [PASS] test_add_target_wrapper_adds_target")

def test_add_target_wrapper_passes_through_args():
    """Test that wrapper passes arguments through."""
    received = []
    def original_fn(crd_paths):
        received.append(crd_paths)
        return {'services': {}}
    
    wrapped = add_target_wrapper(original_fn, 'test-dep')
    wrapped(['/path/to/crds'])
    
    assert_equals(received[0], ['/path/to/crds'], "Args should pass through")
    print("  [PASS] test_add_target_wrapper_passes_through_args")

# ============================================================================
# Profile Tests
# ============================================================================

def test_is_dep_included_no_profiles_always_included():
    """Test that deps with no profiles are always included."""
    # No profiles on dep = always included
    assert_true(is_dep_included_by_profile([], []), "No profiles, no active = included")
    assert_true(is_dep_included_by_profile([], ['dev']), "No profiles, active dev = included")
    assert_true(is_dep_included_by_profile([], ['dev', 'staging']), "No profiles, multiple active = included")
    print("  [PASS] test_is_dep_included_no_profiles_always_included")

def test_is_dep_included_with_profiles_needs_match():
    """Test that deps with profiles need at least one match."""
    # Dep has profiles, no active profiles = excluded
    assert_true(not is_dep_included_by_profile(['dev'], []), "Has profile, no active = excluded")
    
    # Dep has profiles, matching active = included
    assert_true(is_dep_included_by_profile(['dev'], ['dev']), "Matching profile = included")
    assert_true(is_dep_included_by_profile(['dev', 'staging'], ['dev']), "One match = included")
    assert_true(is_dep_included_by_profile(['dev'], ['dev', 'staging']), "One match = included")
    
    # Dep has profiles, no match = excluded
    assert_true(not is_dep_included_by_profile(['dev'], ['staging']), "No match = excluded")
    assert_true(not is_dep_included_by_profile(['dev', 'full'], ['staging', 'test']), "No match = excluded")
    print("  [PASS] test_is_dep_included_with_profiles_needs_match")

def test_cc_local_composable_with_profiles():
    """Test creating cc_local_composable with profiles."""
    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
        profiles=['dev', 'staging'],
    )
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.profiles, ['dev', 'staging'])
    print("  [PASS] test_cc_local_composable_with_profiles")

def test_cc_local_composable_with_labels():
    """Test creating cc_local_composable with labels."""
    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
        labels=['app'],
    )
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(plugin.labels, ['app'])
    print("  [PASS] test_cc_local_composable_with_labels")

def test_cc_local_composable_labels_default_empty():
    """Test that labels default to empty list."""
    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
    )
    assert_equals(plugin.labels, [])
    print("  [PASS] test_cc_local_composable_labels_default_empty")

# ============================================================================
# Modifications Tests
# ============================================================================

def test_cc_local_composable_with_modifications():
    """Test creating cc_local_composable with modifications parameter."""
    # Create a mock modification dict
    mod = {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['test:/test']}}}

    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod],
    )
    assert_equals(plugin.name, 'my-plugin')
    assert_equals(len(plugin.modifications), 1)
    assert_equals(plugin.modifications[0]['_target'], 'k3s-apiserver')
    print("  [PASS] test_cc_local_composable_with_modifications")

def test_cc_local_composable_modifications_default_empty():
    """Test that modifications default to empty list."""
    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
    )
    assert_equals(plugin.modifications, [])
    print("  [PASS] test_cc_local_composable_modifications_default_empty")

def test_cc_local_composable_multiple_modifications():
    """Test plugin with multiple modifications."""
    mod1 = {'_target': 'k3s-apiserver', 'services': {'crd-loader': {'volumes': ['crds1:/crds1']}}}
    mod2 = {'_target': 'mysql', 'services': {'db': {'environment': ['TEST=1']}}}

    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod1, mod2],
    )
    assert_equals(len(plugin.modifications), 2)
    assert_equals(plugin.modifications[0]['_target'], 'k3s-apiserver')
    assert_equals(plugin.modifications[1]['_target'], 'mysql')
    print("  [PASS] test_cc_local_composable_multiple_modifications")

def test_struct_to_dict_preserves_modifications():
    """Test that struct_to_dict preserves modifications field."""
    mod = {'_target': 'k3s-apiserver', 'services': {'test': {}}}
    plugin = cc_local_composable(
        'my-plugin',
        '/path/to/compose.yaml',
        modifications=[mod],
    )

    plugin_dict = struct_to_dict(plugin)
    assert_equals(len(plugin_dict['modifications']), 1)
    assert_equals(plugin_dict['modifications'][0]['_target'], 'k3s-apiserver')
    print("  [PASS] test_struct_to_dict_preserves_modifications")

def test_flatten_dependency_tree_with_profiles():
    """Test that dependency tree respects profiles."""
    always_included = struct(
        name='always',
        url='file:///path',
        ref=None,
        repo_path='always',
        compose_path='/path/always.yaml',
        compose_overrides={},
        dependencies=[],
        profiles=[],  # No profiles = always included
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    dev_only = struct(
        name='dev-only',
        url='file:///path',
        ref=None,
        repo_path='dev-only',
        compose_path='/path/dev.yaml',
        compose_overrides={},
        dependencies=[],
        profiles=['dev'],  # Only in dev
        _symbols={},
        _from_cli=False,
        _is_local=False,
    )
    
    root = cc_local_composable('root', '/path/root.yaml', always_included, dev_only)
    
    # With no active profiles, only 'always' should be included
    result = flatten_dependency_tree(root, [], None, [])
    names = [r['name'] for r in result]
    assert_in('always', names)
    assert_in('root', names)
    assert_true('dev-only' not in names, "dev-only should be excluded with no profiles")
    
    # With 'dev' profile, both should be included
    result_dev = flatten_dependency_tree(root, [], None, ['dev'])
    names_dev = [r['name'] for r in result_dev]
    assert_in('always', names_dev)
    assert_in('dev-only', names_dev)
    assert_in('root', names_dev)
    
    print("  [PASS] test_flatten_dependency_tree_with_profiles")

def test_cc_get_active_profiles():
    """Test that cc_get_active_profiles returns a list."""
    profiles = cc_get_active_profiles()
    assert_true(type(profiles) == 'list', "Should return a list")
    print("  [PASS] test_cc_get_active_profiles")

# ============================================================================
# Run All Tests
# ============================================================================

def run_tests():
    print("\n=== deep_merge Tests ===")
    test_deep_merge_simple_dicts()
    test_deep_merge_nested_dicts()
    test_deep_merge_lists_concatenate()
    test_deep_merge_lists_dedup()
    test_deep_merge_does_not_mutate()
    test_deep_merge_compose_overrides()
    
    print("\n=== cc_local_composable Tests ===")
    test_cc_local_composable_basic()
    test_cc_local_composable_with_dependencies()
    
    print("\n=== flatten_dependency_tree Tests ===")
    test_flatten_dependency_tree_simple()
    test_flatten_dependency_tree_nested()
    test_flatten_dependency_tree_deduplicates()
    test_flatten_dependency_tree_with_cli_plugins()
    
    print("\n=== is_url Tests ===")
    test_is_url_https()
    test_is_url_file()
    test_is_url_git_ssh()
    test_is_url_not_url()
    
    print("\n=== resolve_plugin_spec Tests ===")
    test_resolve_plugin_spec_url()
    test_resolve_plugin_spec_absolute()
    test_resolve_plugin_spec_relative()
    test_resolve_plugin_spec_adjacent()
    
    print("\n=== collect_wire_when_rules Tests ===")
    test_collect_wire_when_rules_empty()
    test_collect_wire_when_rules_single()
    test_collect_wire_when_rules_multiple()
    
    print("\n=== apply_wire_when_rules Tests ===")
    test_apply_wire_when_rules_adds_depends_on()
    test_apply_wire_when_rules_adds_volumes()
    test_apply_wire_when_rules_adds_environment()
    test_apply_wire_when_rules_skips_when_trigger_missing()
    test_apply_wire_when_rules_creates_top_level_volumes()
    
    print("\n=== struct_to_dict Tests ===")
    test_struct_to_dict_basic()
    test_struct_to_dict_cc_local_composable()
    test_struct_to_dict_preserves_compose_overrides()
    
    print("\n=== apply_modifications Tests ===")
    test_apply_modifications_single()
    test_apply_modifications_multiple_same_target()
    test_apply_modifications_missing_target()
    
    print("\n=== add_target_wrapper Tests ===")
    test_add_target_wrapper_adds_target()
    test_add_target_wrapper_passes_through_args()
    
    print("\n=== Profile Tests ===")
    test_is_dep_included_no_profiles_always_included()
    test_is_dep_included_with_profiles_needs_match()
    test_cc_local_composable_with_profiles()
    test_flatten_dependency_tree_with_profiles()
    test_cc_get_active_profiles()

    print("\n=== Label Tests ===")
    test_cc_local_composable_with_labels()
    test_cc_local_composable_labels_default_empty()

    print("\n=== Modifications Tests ===")
    test_cc_local_composable_with_modifications()
    test_cc_local_composable_modifications_default_empty()
    test_cc_local_composable_multiple_modifications()
    test_struct_to_dict_preserves_modifications()

    print("\n" + "=" * 50)
    print("All tests passed!")
    print("=" * 50)

# Run tests
run_tests()

# Dummy resource to satisfy tilt ci (which expects at least one resource)
local_resource('tests', cmd='echo "Tests completed"', auto_init=False)
